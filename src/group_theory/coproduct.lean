/-
Copyright (c) 2021 David Wärn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Wärn
-/
import data.list.chain
/-!
# The free product of groups or monoids

Given an `ι`-indexed family `M` of monoids, where both `ι` and all `M i` have decidable
equality, we define the free product `free_product M` of `M` as the type of reduced words, and show
that it has the universal property of a coproduct. One could define the free product more abstractly
in terms of its presentation, but this definition has the advantage of giving decidable equality.

When `M i` are all groups, we show that `free_product M` is also a group.

## Main definitions

- `free_product M`
- `of {i}`: the embedding `M i →* free_product M`.
- `lift X : (Π {i}, M i →* X) ≃ (free_product M →* X)`: the free product is a categorical coproduct.

## Idea

We define the monoid structure on `free_product M` by letting each `M i` act on `free_product M`.
One way to understand this is that each `M i` thus maps into the monoid
`free_product M → free_product M`, and the submonoid generated by their images bijects with
`free_product M` by evaluation at `[]`, inducing a monoid structure on `free_product M`.
We take the shortcut of not introducing `free_product M → free_product M` or this bijection.

## References

[van der Waerden, *Free products of groups*][MR25465]

-/

variables {ι : Type*} (M : Π i : ι, Type*) [Π i, monoid (M i)]
  [decidable_eq ι] [∀ i, decidable_eq (M i)]

/-- `free_product M` is the free product, or categorical coproduct, of a family `M` of monoids.
This assumes that the indexing type and each monoid all have decidable equality. -/
@[derive decidable_eq, nolint unused_arguments]
def free_product : Type* := { l : list (Σ i, { m : M i // m ≠ 1 }) // (l.map sigma.fst).chain' (≠) }
variable {M}

namespace free_product

/-- `w.head_is_not i` says that `i` is not the index of the first letter in `w`. That is, either
the head has a different index or `w` is the empty word. -/
def head_is_not (w : free_product M) (i : ι) : Prop :=
∀ p ∈ (w.val.map sigma.fst).head', i ≠ p

section cases

variables {i : ι} {C : free_product M → Sort*}
  (d1 : Π w : free_product M, w.head_is_not i → C w)
  (d2 : Π (w : free_product M) (h : w.head_is_not i) (m) {x}, C ⟨⟨i, m⟩ :: w.val, x⟩)
include d2

/-- A custom eliminator for the free product. The idea is that given an index `i` and a word `w`,
either `i` is not the head of `w`, or `w` is `⟨i, m⟩ :: w'` for some word `w'` whose head is not
`i`. In principle these two cases can be unified using `rcons'`. -/
protected def cases : Π w : free_product M, C w
| w@⟨[], _⟩ := d1 w $ by rintro _ ⟨⟩
| w@⟨⟨j, m⟩ :: ls, h⟩ := if ij : i = j then by { cases ij, exact d2 ⟨ls, h.tail⟩ h.rel_head' m }
else d1 w $ by { rintro _ ⟨⟩, exact ij }

variables {d1 d2}

/-- Computation rule for the first case of `free_product.cases`. -/
lemma beta1 : ∀ (w : free_product M) (h : w.head_is_not i), w.cases d1 d2 = d1 w h
| ⟨[], _⟩ h := rfl
| ⟨⟨j, m⟩ :: ls, hl⟩ h := dif_neg (h j rfl)

/-- Computation rule for the second case of `free_product.cases`. -/
lemma beta2 : ∀ (w : free_product M) (h : w.head_is_not i) (m) {x},
  free_product.cases d1 d2 ⟨⟨i, m⟩ :: w.val, x⟩ = d2 w h m
| ⟨ls, hl⟩ h m x := dif_pos rfl

end cases

/-- Prepend `m : M i` to `w`, assuming `i` is not the head of `w`. If `m = 1`, do nothing. -/
def rcons' {i : ι} (m : M i) (w : free_product M) (h : w.head_is_not i) : free_product M :=
if m_one : m = 1 then w else ⟨⟨i, m, m_one⟩ :: w.val, w.property.cons' h⟩

/-- Prepend `m : M i` to `w`. We define this by reducing to the case where `i` is not the head of
`w`. This will be a recurring theme. -/
def rcons {i : ι} (m : M i) (w : free_product M) : free_product M :=
w.cases (rcons' m) (λ w' h m' x, rcons' (m * ↑m') w' h)

/-- First computation rule for `rcons`. -/
lemma rcons_def1 {i : ι} {m : M i} {w : free_product M} (h) : rcons m w = rcons' m w h := beta1 w h
/-- Second computation rule for `rcons`. -/
lemma rcons_def2 {i : ι} {m : M i} {w : free_product M} (h) (m') {x} :
  rcons m ⟨⟨i, m'⟩ :: w.val, x⟩ = rcons' (m * ↑m') w h := beta2 w h m'

/-- Prepending `1` leaves every word unchanged. -/
lemma rcons_one {i : ι} (w : free_product M) : rcons (1 : M i) w = w :=
w.cases (λ w h, by rw [rcons_def1 h, rcons', dif_pos rfl])
(λ w h ⟨g, hg⟩, by { rw [rcons_def2 h, one_mul, rcons', dif_neg], refl })

/-- Preliminary for `rcons_mul`. -/
private lemma rcons_mul' {i : ι} {m m' : M i} (w : free_product M) (h : w.head_is_not i) :
  rcons (m * m') w = rcons m (rcons m' w) :=
begin
  by_cases hm' : m' = 1,
  { rw [hm', rcons_one, mul_one], },
  conv_rhs { rw [rcons_def1 h, rcons', dif_neg hm', rcons_def2 h], },
  exact rcons_def1 h,
end

/-- We can prepend `m * m'` one element at a time. -/
lemma rcons_mul {i : ι} (m : M i) (m' : M i) (w) : rcons (m * m') w = rcons m (rcons m' w) :=
w.cases rcons_mul' $ λ w' h g'' x,
by rw [rcons_def2 h, rcons_def2 h, mul_assoc, ←rcons_def1, rcons_mul' _ h, ←rcons_def1]

/-- The action of `M i` on `free_product M`. -/
instance (i) : mul_action (M i) (free_product M) :=
{ smul := rcons, one_smul := rcons_one, mul_smul := rcons_mul }

/-- A word obtained by prepending a letter can also be obtained by acting on its tail. -/
lemma cons_as_smul {i} {m} (ls) (hl) :
 (⟨⟨i, m⟩ :: ls, hl⟩ : free_product M) = (m.val • ⟨ls, hl.tail⟩ : free_product M) :=
begin
  cases m with m hm, change _ = rcons _ _,
  rw [rcons_def1, rcons', dif_neg hm],
  { refl, }, { exact hl.rel_head', },
end

section action
variables {X : Type*} [∀ i, mul_action (M i) X]

/-- Given actions of `M i` on `X`, the coproduct also has a scalar action on `X`. We'll use this
both to define multiplication in the coproduct, and to get its universal property. -/
instance : has_scalar (free_product M) X := ⟨λ w x, w.val.foldr (λ p y, p.snd.val • y) x⟩

/-- A preliminary for the following instance. -/
private lemma is_scalar_tower' {i} {m : M i} {x : X} (w : free_product M) (h : w.head_is_not i) :
  (rcons m w) • x = m • (w • x) :=
by { rw [rcons_def1 h, rcons'], split_ifs, { rw [h_1, one_smul], }, { refl, }, }

/-- A key associativity lemma describing the interaction between the three actions. -/
instance (i) : is_scalar_tower (M i) (free_product M) X :=
⟨λ m' w x, w.cases is_scalar_tower' $ λ w' h m y, begin
  change (rcons _ _) • _ = _,
  rw [rcons_def2 h, ←rcons_def1 h, is_scalar_tower' _ h, mul_smul],
  refl,
end⟩

end action

instance : monoid (free_product M) :=
{ mul := λ x y, x • y,
  mul_assoc := begin
    rintros ⟨ls, hl⟩ b c,
    change (_ • _) • _ = _ • (_ • _),
    induction ls with p ls ih,
    { refl, },
    cases p with i m,
    rw [cons_as_smul, smul_assoc m.val _ b, smul_assoc, ih, smul_assoc],
    apply_instance, -- TODO why do we have to write this?
  end,
  one := ⟨[], list.chain'_nil⟩,
  one_mul := λ _, rfl,
  mul_one := begin
    rintro ⟨ls, hl⟩,
    change _ • _ = _,
    induction ls with p ls ih,
    { refl },
    { cases p with i m, rw [cons_as_smul, smul_assoc, ih], },
  end }

instance : inhabited (free_product M) := ⟨1⟩

/-- The inclusion into the free product. -/
def of {i} : M i →* free_product M :=
{ to_fun := λ m, m • 1,
  map_one' := rcons_one _,
  map_mul' := by { intros, change _ = _ • _, rw [mul_smul, smul_one_smul], } }

lemma cons_as_mul {i} {m} (ls) (h) :
 (⟨⟨i, m⟩ :: ls, h⟩ : free_product M) = (of m.val * ⟨ls, h.tail⟩ : free_product M) :=
by { change _ = (_ • _) • (_ : free_product M), rw [cons_as_smul, smul_one_smul], }

/-- The universal property of the free product: a monoid homomorphism from the `free_product M` is
uniquely determined by a family of homomorphisms from the `M i`.-/
def lift (X : Type*) [monoid X] : (Π {i}, M i →* X) ≃ (free_product M →* X) :=
{ to_fun := λ fi, begin
    letI : ∀ i, mul_action (M i) X := λ i, mul_action.comp_hom _ fi,
    refine { to_fun := λ w, w • 1, map_one' := rfl, map_mul' := _ },
    rintros ⟨ls, hl⟩ b,
    change (_ • _) • _ = _,
    induction ls with p ls ih,
    { exact (one_mul _).symm },
    cases p with i m,
    rw [cons_as_smul, smul_assoc m.val _ b, smul_assoc, ih, smul_assoc],
    { exact (mul_assoc _ _ _).symm },
    { apply_instance },
  end,
  inv_fun := λ f i, f.comp of,
  left_inv := begin
    intro fi, letI : ∀ i, mul_action (M i) X := λ i, mul_action.comp_hom _ fi,
    ext i m, change (m • _) • (1 : X) = fi m,
    rw smul_assoc, apply mul_one,
  end,
  right_inv := begin
    intro f,
    ext w,
    cases w with ls hl,
    change _ • 1 = f ⟨ls, hl⟩,
    induction ls with p ls ih,
    { exact f.map_one.symm },
    cases p with i m,
    conv_rhs { rw [cons_as_mul, f.map_mul] },
    letI : mul_action (M i) X := mul_action.comp_hom _ (f.comp of),
    rw [cons_as_smul, smul_assoc, ih], refl
  end }

lemma prod_eq_self (w : free_product M) : list.prod (w.val.map (λ l, of l.snd.val)) = w :=
begin
  cases w with ls hl, induction ls with p ls ih,
  { refl, }, { cases p, rw [list.map_cons, list.prod_cons, ih hl.tail, cons_as_mul], },
end

variables {G : Π i : ι, Type*} [Π i, group (G i)] [∀ i, decidable_eq (G i)]

instance : group (free_product G) :=
{ inv := λ w, ⟨list.reverse (w.val.map $ λ l, ⟨l.fst, l.snd.val⁻¹, inv_ne_one.mpr l.snd.property⟩),
    by simpa [eq_comm, flip, list.chain'_reverse] using w.property⟩,
  mul_left_inv := begin
    rintro ⟨ls, junk⟩,
    change list.foldr _ _ (list.reverse _) = _,
    induction ls with p ls ih,
    { refl },
    cases p with i m,
    rw [list.map_cons, list.reverse_cons, list.foldr_append, list.foldr, list.foldr,
      cons_as_smul, smul_smul, mul_left_inv, one_smul, ih]
  end,
  ..free_product.monoid }

end free_product
