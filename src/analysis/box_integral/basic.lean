import analysis.box_integral.partition.filter
import analysis.box_integral.partition.additive
import analysis.normed_space.operator_norm
import topology.uniform_space.compact_separated

open_locale big_operators classical topological_space nnreal filter
open set function filter continuous_linear_map (lsmul)

noncomputable theory

namespace box_integral

variables {Œπ E F : Type*} [normed_group E] [normed_space ‚Ñù E] [normed_group F] [normed_space ‚Ñù F]
  {I : box Œπ} {œÄ : marked_partition I}

namespace partition

def union {I : box Œπ} {i : Œπ} {x : ‚Ñù} {hx : x ‚àà Ioo (I.lower i) (I.upper i)}
  (œÄ‚ÇÅ : partition (I.split_edge_lower i x hx))
  (œÄ‚ÇÇ : partition (I.split_edge_upper i x hx)) :
  partition I :=
{ boxes := œÄ‚ÇÅ.boxes ‚à™ œÄ‚ÇÇ.boxes,
  finite_boxes := œÄ‚ÇÅ.finite_boxes.union œÄ‚ÇÇ.finite_boxes,
  bUnion_boxes_coe := by rw [bUnion_union, bUnion_boxes_coe, bUnion_boxes_coe,
    box.union_coe_split_edge],
  pairwise_disjoint :=
    begin
      rintro J‚ÇÅ (hJ‚ÇÅ|hJ‚ÇÅ) J‚ÇÇ (hJ‚ÇÇ|hJ‚ÇÇ) Hne,
      exacts [œÄ‚ÇÅ.pairwise_disjoint J‚ÇÅ hJ‚ÇÅ J‚ÇÇ hJ‚ÇÇ Hne,
        (I.disjoint_split_edge i x hx).mono (œÄ‚ÇÅ.le_of_mem hJ‚ÇÅ) (œÄ‚ÇÇ.le_of_mem hJ‚ÇÇ),
        (I.disjoint_split_edge i x hx).symm.mono (œÄ‚ÇÇ.le_of_mem hJ‚ÇÅ) (œÄ‚ÇÅ.le_of_mem hJ‚ÇÇ),
        œÄ‚ÇÇ.pairwise_disjoint J‚ÇÅ hJ‚ÇÅ J‚ÇÇ hJ‚ÇÇ Hne]
    end }

end partition

namespace marked_partition

def union {I : box Œπ} {i : Œπ} {x : ‚Ñù} {hx : x ‚àà Ioo (I.lower i) (I.upper i)}
  (œÄ‚ÇÅ : marked_partition (I.split_edge_lower i x hx))
  (œÄ‚ÇÇ : marked_partition (I.split_edge_upper i x hx)) :
  marked_partition I :=
{ to_partition := œÄ‚ÇÅ.to_partition.union œÄ‚ÇÇ.to_partition,
  mark := Œª J, if J ‚àà œÄ‚ÇÅ then œÄ‚ÇÅ.mark J else œÄ‚ÇÇ.mark J,
  mark_mem_Icc := Œª J,
    begin
      split_ifs,
      exacts [box.le_iff_Icc.1 (I.split_edge_lower_le i x hx) (œÄ‚ÇÅ.mark_mem_Icc _),
        box.le_iff_Icc.1 (I.split_edge_upper_le i x hx) (œÄ‚ÇÇ.mark_mem_Icc _)]
    end }

lemma is_subordinate.union [fintype Œπ] {I : box Œπ} {i : Œπ} {x : ‚Ñù}
  {hx : x ‚àà Ioo (I.lower i) (I.upper i)}
  {œÄ‚ÇÅ : marked_partition (I.split_edge_lower i x hx)}
  {œÄ‚ÇÇ : marked_partition (I.split_edge_upper i x hx)} {r : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñù}
  (h‚ÇÅ : is_subordinate œÄ‚ÇÅ r) (h‚ÇÇ : is_subordinate œÄ‚ÇÇ r) :
  is_subordinate (œÄ‚ÇÅ.union œÄ‚ÇÇ) r :=
begin
  intros J hJ,
  by_cases hJ‚ÇÅ : J ‚àà œÄ‚ÇÅ,
  { simp only [union, if_pos hJ‚ÇÅ, h‚ÇÅ J hJ‚ÇÅ] },
  { simp only [union, if_neg hJ‚ÇÅ, h‚ÇÇ J (hJ.resolve_left hJ‚ÇÅ)] }
end

lemma is_Henstock.union [fintype Œπ] {I : box Œπ} {i : Œπ} {x : ‚Ñù}
  {hx : x ‚àà Ioo (I.lower i) (I.upper i)}
  {œÄ‚ÇÅ : marked_partition (I.split_edge_lower i x hx)}
  {œÄ‚ÇÇ : marked_partition (I.split_edge_upper i x hx)}
  (h‚ÇÅ : is_Henstock œÄ‚ÇÅ) (h‚ÇÇ : is_Henstock œÄ‚ÇÇ) :
  is_Henstock (œÄ‚ÇÅ.union œÄ‚ÇÇ) :=
begin
  intros J hJ,
  by_cases hJ‚ÇÅ : J ‚àà œÄ‚ÇÅ,
  { simp only [union, if_pos hJ‚ÇÅ, h‚ÇÅ J hJ‚ÇÅ] },
  { simp only [union, if_neg hJ‚ÇÅ, h‚ÇÇ J (hJ.resolve_left hJ‚ÇÅ)] }
end

lemma tendsto_union_Henstock [fintype Œπ] {I : box Œπ} {i : Œπ} {x : ‚Ñù}
  (hx : x ‚àà Ioo (I.lower i) (I.upper i)) :
  tendsto (Œª œÄ : marked_partition (I.split_edge_lower i x hx) √ó
    marked_partition (I.split_edge_upper i x hx), œÄ.1.union œÄ.2)
    (Henstock √ó·∂† Henstock) Henstock :=
begin
  refine ((has_basis_Henstock.prod has_basis_Henstock).tendsto_iff has_basis_Henstock).2 _,
  refine Œª r hr, ‚ü®(r, r), ‚ü®Œª x hx, hr x _, Œª x hx, hr x _‚ü©, _‚ü©,
  { exact box.le_iff_Icc.1 (I.split_edge_lower_le _ _ _) hx },
  { exact box.le_iff_Icc.1 (I.split_edge_upper_le _ _ _) hx },
  { rintro ‚ü®œÄ‚ÇÅ, œÄ‚ÇÇ‚ü© ‚ü®‚ü®h‚ÇÅr, h‚ÇÅ‚ü©, ‚ü®h‚ÇÇr, h‚ÇÇ‚ü©‚ü©,
    exact ‚ü®h‚ÇÅr.union h‚ÇÇr, h‚ÇÅ.union h‚ÇÇ‚ü© }
end

lemma tendsto_union_Henstock'_aux [fintype Œπ] {I : box Œπ} {i : Œπ} {x : ‚Ñù}
  (hx : x ‚àà Ioo (I.lower i) (I.upper i)) (c : ‚Ñù‚â•0) :
  tendsto (Œª œÄ : marked_partition (I.split_edge_lower i x hx) √ó
    marked_partition (I.split_edge_upper i x hx), œÄ.1.union œÄ.2)
    (Henstock'_aux c √ó·∂† Henstock'_aux c) (Henstock'_aux c) :=
begin
  rw [Henstock'_aux, Henstock'_aux, ‚Üê prod_inf_prod, prod_principal_principal],
  refine (tendsto_union_Henstock hx).inf (tendsto_principal_principal.2 _),
  rintro ‚ü®œÄ‚ÇÅ, œÄ‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© J (hJ|hJ),
  exacts [h‚ÇÅ J hJ, h‚ÇÇ J hJ]
end

lemma tendsto_union_Riemann [fintype Œπ] {I : box Œπ} {i : Œπ} {x : ‚Ñù}
  (hx : x ‚àà Ioo (I.lower i) (I.upper i)) :
  tendsto (Œª œÄ : marked_partition (I.split_edge_lower i x hx) √ó
    marked_partition (I.split_edge_upper i x hx), œÄ.1.union œÄ.2)
    (Riemann √ó·∂† Riemann) Riemann :=
begin
  refine ((has_basis_Riemann.prod has_basis_Riemann).tendsto_iff has_basis_Riemann).2 _,
  refine Œª r hr, ‚ü®(r, r), ‚ü®hr, hr‚ü©, _‚ü©,
  rintro ‚ü®œÄ‚ÇÅ, œÄ‚ÇÇ‚ü© ‚ü®‚ü®h‚ÇÅr, h‚ÇÅ‚ü©, ‚ü®h‚ÇÇr, h‚ÇÇ‚ü©‚ü©,
  exact ‚ü®h‚ÇÅr.union h‚ÇÇr, h‚ÇÅ.union h‚ÇÇ‚ü©
end

end marked_partition

open marked_partition

def integral_sum (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (œÄ : marked_partition I) : F :=
‚àë·∂† J ‚àà œÄ, vol J (f (œÄ.mark J))

@[simp] lemma integral_sum_add (f g : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (œÄ : marked_partition I) :
  integral_sum (f + g) vol œÄ = integral_sum f vol œÄ + integral_sum g vol œÄ :=
begin
  simp only [integral_sum, pi.add_apply, (vol _).map_add],
  exact finsum_mem_add_distrib œÄ.finite_boxes
end

@[simp] lemma integral_sum_neg (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (œÄ : marked_partition I) :
  integral_sum (-f) vol œÄ = -integral_sum f vol œÄ :=
by simp only [integral_sum, pi.neg_apply, (vol _).map_neg, finsum_neg_distrib]

@[simp] lemma integral_sum_smul (c : ‚Ñù) (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (œÄ : marked_partition I) :
  integral_sum (c ‚Ä¢ f) vol œÄ = c ‚Ä¢ integral_sum f vol œÄ :=
by simp only [integral_sum, smul_finsum, pi.smul_apply, continuous_linear_map.map_smul]

def has_integral (I : box Œπ) (l : filter (marked_partition I)) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (y : F) : Prop :=
tendsto (integral_sum f vol) l (ùìù y)

def integrable (I : box Œπ) (l : filter (marked_partition I)) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) : Prop :=
‚àÉ y, has_integral I l vol f y

def integral (I : box Œπ) (l : filter (marked_partition I)) (vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F))
  (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) : F :=
if h : integrable I l vol f then classical.some h else 0

variables {l : filter (marked_partition I)}
  {f g : (Œπ ‚Üí ‚Ñù) ‚Üí E} {vol : box Œπ ‚Üí (E ‚ÜíL[‚Ñù] F)} {y y' : F}

lemma has_integral.tendsto (h : has_integral I l vol f y) :
  tendsto (integral_sum f vol) l (ùìù y) := h

lemma integrable_iff_cauchy [complete_space F] [ne_bot l] :
  integrable I l vol f ‚Üî cauchy (l.map (integral_sum f vol)) :=
cauchy_map_iff_exists_tendsto.symm

lemma integrable_iff_ex_basis [complete_space F] [ne_bot l] {Œπ' : Sort*} {p : Œπ' ‚Üí Prop}
  {s : Œπ' ‚Üí set (marked_partition I)} (h : has_basis l p s) :
  integrable I l vol f ‚Üî
    ‚àÄ Œµ > 0, ‚àÉ j (hi : p j), ‚àÄ œÄ‚ÇÅ œÄ‚ÇÇ ‚àà s j, ‚à•integral_sum f vol œÄ‚ÇÅ - integral_sum f vol œÄ‚ÇÇ‚à• ‚â§ Œµ :=
by simp only [integrable_iff_cauchy, cauchy_map_iff, ‚Äπne_bot l‚Ä∫, true_and,
  h.prod_self.tendsto_iff metric.uniformity_basis_dist_le, prod.forall, set.mem_prod, and_imp,
  mem_set_of_eq, dist_eq_norm, gt_iff_lt]

lemma has_integral.R'_to_R [fintype Œπ] (h : has_integral I Riemann' vol f y) :
  has_integral I Riemann vol f y :=
h.mono_left Riemann_le_Riemann'

lemma has_integral.R_to_H [fintype Œπ] (h : has_integral I Riemann vol f y) :
  has_integral I Henstock vol f y :=
h.mono_left Henstock_le_Riemann

lemma has_integral.R'_to_MS [fintype Œπ] (h : has_integral I Riemann' vol f y) :
  has_integral I McShane vol f y :=
h.mono_left McShane_le_Riemann'

lemma has_integral.MS_to_H [fintype Œπ] (h : has_integral I McShane vol f y) :
  has_integral I Henstock vol f y :=
h.mono_left Henstock_le_McShane

lemma has_integral.H_to_H' [fintype Œπ] (h : has_integral I Henstock vol f y) :
  has_integral I Henstock' vol f y :=
h.mono_left Henstock'_le_Henstock

lemma integrable.has_integral (h : integrable I l vol f) :
  has_integral I l vol f (integral I l vol f) :=
by { rw [integral, dif_pos h], exact classical.some_spec h }

lemma integrable.mono {l'} (h : integrable I l vol f) (hle : l' ‚â§ l) : integrable I l' vol f :=
‚ü®_, h.has_integral.mono_left hle‚ü©

lemma integrable.R'_to_R [fintype Œπ] (h : integrable I Riemann' vol f) :
  integrable I Riemann vol f :=
h.mono Riemann_le_Riemann'

lemma integrable.R_to_H [fintype Œπ] (h : integrable I Riemann vol f) :
  integrable I Henstock vol f :=
h.mono Henstock_le_Riemann

lemma integrable.R'_to_MS [fintype Œπ] (h : integrable I Riemann' vol f) :
  integrable I McShane vol f :=
h.mono McShane_le_Riemann'

lemma integrable.MS_to_H [fintype Œπ] (h : integrable I McShane vol f) :
  integrable I Henstock vol f :=
h.mono Henstock_le_McShane

lemma integrable.H_to_H' [fintype Œπ] (h : integrable I Henstock vol f) :
  integrable I Henstock' vol f :=
h.mono Henstock'_le_Henstock

lemma has_integral.unique [ne_bot l] (h : has_integral I l vol f y)
  (h' : has_integral I l vol f y') :
  y = y' :=
tendsto_nhds_unique h h'

lemma has_integral.integrable (h : has_integral I l vol f y) : integrable I l vol f := ‚ü®_, h‚ü©

lemma has_integral.integral_eq [ne_bot l] (h : has_integral I l vol f y) :
  integral I l vol f = y :=
h.integrable.has_integral.unique h

lemma has_integral.add (h : has_integral I l vol f y) (h' : has_integral I l vol g y') :
  has_integral I l vol (f + g) (y + y') :=
by simpa only [has_integral, ‚Üê integral_sum_add] using h.add h'

lemma integrable.add (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integrable I l vol (f + g) :=
(hf.has_integral.add hg.has_integral).integrable

lemma integral_add [ne_bot l] (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integral I l vol (f + g) = integral I l vol f + integral I l vol g :=
(hf.has_integral.add hg.has_integral).integral_eq

lemma has_integral.neg (hf : has_integral I l vol f y) : has_integral I l vol (-f) (-y) :=
by simpa only [has_integral, ‚Üê integral_sum_neg] using hf.neg

lemma integrable.neg (hf : integrable I l vol f) : integrable I l vol (-f) :=
hf.has_integral.neg.integrable

lemma integrable.of_neg (hf : integrable I l vol (-f)) : integrable I l vol f := neg_neg f ‚ñ∏ hf.neg

@[simp] lemma integrable_neg : integrable I l vol (-f) ‚Üî integrable I l vol f :=
‚ü®Œª h, h.of_neg, Œª h, h.neg‚ü©

@[simp] lemma integral_neg [ne_bot l] : integral I l vol (-f) = -integral I l vol f :=
if h : integrable I l vol f then h.has_integral.neg.integral_eq
else by rw [integral, integral, dif_neg h, dif_neg (mt integrable.of_neg h), neg_zero]

lemma has_integral.sub (h : has_integral I l vol f y) (h' : has_integral I l vol g y') :
  has_integral I l vol (f - g) (y - y') :=
by simpa only [sub_eq_add_neg] using h.add h'.neg

lemma integrable.sub (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integrable I l vol (f - g) :=
(hf.has_integral.sub hg.has_integral).integrable

lemma integral_sub [ne_bot l] (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integral I l vol (f - g) = integral I l vol f - integral I l vol g :=
(hf.has_integral.sub hg.has_integral).integral_eq

lemma has_integral_zero : has_integral I l vol (Œª _, (0:E)) 0 :=
by { dunfold has_integral, convert tendsto_const_nhds, ext œÄ, simp [integral_sum] }

lemma integrable_zero : integrable I l vol (Œª _, (0:E)) := ‚ü®0, has_integral_zero‚ü©

@[simp] lemma integral_zero [ne_bot l] : integral I l vol (Œª _, (0:E)) = 0 :=
has_integral_zero.integral_eq

lemma has_integral_sum {Œ± : Type*} {s : finset Œ±} {f : Œ± ‚Üí (Œπ ‚Üí ‚Ñù) ‚Üí E} {g : Œ± ‚Üí F}
  (h : ‚àÄ i ‚àà s, has_integral I l vol (f i) (g i)) :
  has_integral I l vol (Œª x, ‚àë i in s, f i x) (‚àë i in s, g i) :=
begin
  induction s using finset.induction_on with a s ha ihs, { simp [has_integral_zero] },
  simp only [finset.sum_insert ha], rw finset.forall_mem_insert at h,
  exact h.1.add (ihs h.2)
end

lemma has_integral.smul (hf : has_integral I l vol f y) (c : ‚Ñù) :
  has_integral I l vol (c ‚Ä¢ f) (c ‚Ä¢ y) :=
by simpa only [has_integral, ‚Üê integral_sum_smul]
  using (tendsto_const_nhds : tendsto _ _ (ùìù c)).smul hf

lemma integrable.smul (hf : integrable I l vol f) (c : ‚Ñù) :
  integrable I l vol (c ‚Ä¢ f) :=
(hf.has_integral.smul c).integrable

lemma integrable.of_smul {c : ‚Ñù} (hf : integrable I l vol (c ‚Ä¢ f)) (hc : c ‚â† 0) :
  integrable I l vol f :=
by { convert hf.smul c‚Åª¬π, ext x, simp only [pi.smul_apply, inv_smul_smul' hc] }

@[simp] lemma integral_smul [ne_bot l] (c : ‚Ñù) :
  integral I l vol (Œª x, c ‚Ä¢ f x) = c ‚Ä¢ integral I l vol f :=
begin
  rcases eq_or_ne c 0 with rfl | hc, { simp },
  by_cases hf : integrable I l vol f,
  { exact (hf.has_integral.smul c).integral_eq },
  { have : ¬¨integrable I l vol (Œª x, c ‚Ä¢ f x), from mt (Œª h, h.of_smul hc) hf,
    rw [integral, integral, dif_neg hf, dif_neg this, smul_zero] }
end

lemma integral_sum_bUnion_unmarked [fintype Œπ] (œÄ : marked_partition I) (œÄi : Œ† J ‚àà œÄ, partition J)
  (hvol : box_additive_on vol I):
  integral_sum f vol (œÄ.bUnion_unmarked œÄi) = integral_sum f vol œÄ :=
begin
  refine (œÄ.to_partition.finsum_mem_bUnion œÄi _).trans _,
  refine finsum_congr (Œª J, finsum_congr $ Œª hJ, _),
  have : ‚àÄ x, box_additive_on (Œª J', vol J' x) J,
    from Œª x, (hvol.add_monoid_hom_comp (continuous_linear_map.apply ‚Ñù F x)
      .to_linear_map.to_add_monoid_hom).restrict (œÄ.to_partition.le_of_mem hJ),
  calc ‚àë·∂† J' ‚àà œÄi J hJ, vol J' (f (œÄ.mark (œÄ.to_partition.bUnion_index œÄi J'))) =
    ‚àë·∂† J' ‚àà œÄi J hJ, vol J' (f (œÄ.mark J)) :
      finsum_mem_congr rfl (Œª J' (hJ' : J' ‚àà œÄi J hJ), by rw partition.bUnion_index_of_mem _ _ hJ')
  ... = vol J (f (œÄ.mark J)) : (this _).finsum_mem_partition _
end

lemma integral_sum_inf_unmarked [fintype Œπ] (œÄ : marked_partition I) (œÄ' : partition I)
  (hvol : box_additive_on vol I):
  integral_sum f vol (œÄ.inf_unmarked œÄ') = integral_sum f vol œÄ :=
integral_sum_bUnion_unmarked œÄ _ hvol

@[simp] lemma integral_sum_union {i : Œπ} {x : ‚Ñù} {hx : x ‚àà Ioo (I.lower i) (I.upper i)}
  (œÄ‚ÇÅ : marked_partition (I.split_edge_lower i x hx))
  (œÄ‚ÇÇ : marked_partition (I.split_edge_upper i x hx)) :
  integral_sum f vol (œÄ‚ÇÅ.union œÄ‚ÇÇ) = integral_sum f vol œÄ‚ÇÅ + integral_sum f vol œÄ‚ÇÇ :=
begin
  have : disjoint œÄ‚ÇÅ.boxes œÄ‚ÇÇ.boxes,
  { rintro J ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    refine (œÄ‚ÇÅ.to_partition.le_of_mem h‚ÇÅ J.upper_mem i).2.not_lt _,
    simpa using (œÄ‚ÇÇ.to_partition.le_of_mem h‚ÇÇ J.upper_mem i).1 },
  simp only [integral_sum],
  refine (finsum_mem_union this œÄ‚ÇÅ.finite_boxes œÄ‚ÇÇ.finite_boxes).trans _,
  refine congr_arg2 (+) (finsum_mem_congr rfl $ Œª J hJ, _) (finsum_mem_congr rfl $ Œª J hJ, _);
    congr' 2,
  exacts [if_pos hJ, if_neg (Œª h, this ‚ü®h, hJ‚ü©)]
end

lemma integral_sum_sub_partitions [fintype Œπ] (œÄ‚ÇÅ œÄ‚ÇÇ : marked_partition I)
  (hvol : box_additive_on vol I) :
  integral_sum f vol œÄ‚ÇÅ - integral_sum f vol œÄ‚ÇÇ =
    ‚àë·∂† J ‚àà œÄ‚ÇÅ.to_partition ‚äì œÄ‚ÇÇ.to_partition,
      (vol J (f $ (œÄ‚ÇÅ.inf_unmarked œÄ‚ÇÇ.to_partition).mark J) -
        vol J (f $ (œÄ‚ÇÇ.inf_unmarked œÄ‚ÇÅ.to_partition).mark J)) :=
begin
  erw [‚Üê integral_sum_inf_unmarked œÄ‚ÇÅ œÄ‚ÇÇ.to_partition hvol,
    ‚Üê integral_sum_inf_unmarked œÄ‚ÇÇ œÄ‚ÇÅ.to_partition hvol, integral_sum, integral_sum,
    finsum_mem_sub_distrib (partition.finite_boxes _)],
  congr' 1,
  rw inf_comm, refl
end

lemma has_integral_const [fintype Œπ] (hvol : box_additive_on vol I) (c : E) :
  has_integral I l vol (Œª _, c) (vol I c) :=
begin
  refine tendsto_const_nhds.congr (Œª œÄ, _),
  rw [integral_sum, eq_comm],
  refine box_additive_on.finsum_mem_partition _ œÄ.to_partition,
  exact hvol.add_monoid_hom_comp (continuous_linear_map.apply ‚Ñù F c).to_linear_map.to_add_monoid_hom
end

lemma integral_const [fintype Œπ] [ne_bot l] (hvol : box_additive_on vol I) (c : E) :
  integral I l vol (Œª _, c) = vol I c :=
(has_integral_const hvol c).integral_eq

lemma integrable_const [fintype Œπ] (hvol : box_additive_on vol I) (c : E) :
  integrable I l vol (Œª _, c) :=
‚ü®_, has_integral_const hvol c‚ü©

def volume [fintype Œπ] (I : box Œπ) : E ‚ÜíL[‚Ñù] E := lsmul ‚Ñù ‚Ñù I.volume

@[simp] lemma volume_apply [fintype Œπ] (I : box Œπ) (x : E) : volume I x = I.volume ‚Ä¢ x := rfl

lemma box_additive_on_volume [fintype Œπ] (I : box Œπ) :
  box_additive_on (volume : box Œπ ‚Üí E ‚ÜíL[‚Ñù] E) I :=
(box_additive_on_box_volume I).add_monoid_hom_comp
      (lsmul ‚Ñù ‚Ñù : ‚Ñù ‚ÜíL[‚Ñù] E ‚ÜíL[‚Ñù] E).to_linear_map.to_add_monoid_hom

lemma norm_integral_le_of_le_const [fintype Œπ] [ne_bot l] {c : ‚Ñù} (hc : ‚àÄ x ‚àà I.Icc, ‚à•f x‚à• ‚â§ c) :
  ‚à•integral I l volume f‚à• ‚â§ I.volume * c :=
begin
  have h0 : 0 ‚â§ c, from (norm_nonneg _).trans (hc I.upper I.upper_mem_Icc),
  by_cases hf : integrable I l volume f,
  { refine le_of_tendsto' hf.has_integral.norm (Œª œÄ, _),
    erw [integral_sum, œÄ.to_partition.finsum_eq_sum],
    rw [‚Üê (box_additive_on_box_volume I).finsum_mem_partition œÄ.to_partition,
      partition.finsum_eq_sum, finset.sum_mul],
    refine norm_sum_le_of_le _ (Œª J hJ, _), rw finite.mem_to_finset at hJ,
    rw [volume_apply, norm_smul, real.norm_eq_abs, abs_of_pos J.volume_pos,
      mul_le_mul_left J.volume_pos],
    exact hc _ (œÄ.mark_mem_Icc _) },
  { rw [integral, dif_neg hf, norm_zero],
    exact mul_nonneg I.volume_pos.le h0 }
end

lemma box_additive_on_integral_Riemann [fintype Œπ]
  (H : ‚àÄ J ‚â§ I, integrable J Riemann volume f) :
  box_additive_on (Œª J, integral J Riemann volume f) I :=
begin
  intros J hJ i x hx, simp only,
  have A := (H J hJ).has_integral.tendsto.comp (tendsto_union_Riemann hx),
  simp only [(‚àò), integral_sum_union] at A,
  have B := ((H (J.split_edge_lower i x hx) _).has_integral.tendsto.comp tendsto_fst).add
    ((H (J.split_edge_upper i x hx) _).has_integral.tendsto.comp tendsto_snd),
  exacts [tendsto_nhds_unique B A, (J.split_edge_lower_le _ _ _).trans hJ,
    (J.split_edge_upper_le _ _ _).trans hJ]
end

lemma box_additive_on_integral_Henstock [fintype Œπ]
  (H : ‚àÄ J ‚â§ I, integrable J Henstock volume f) :
  box_additive_on (Œª J, integral J Henstock volume f) I :=
begin
  intros J hJ i x hx,
  have A := (H J hJ).has_integral.tendsto.comp (tendsto_union_Henstock hx),
  simp only [(‚àò), integral_sum_union] at A,
  have B := ((H (J.split_edge_lower i x hx) _).has_integral.tendsto.comp tendsto_fst).add
    ((H (J.split_edge_upper i x hx) _).has_integral.tendsto.comp tendsto_snd),
  exacts [tendsto_nhds_unique B A, (J.split_edge_lower_le _ _ _).trans hJ,
    (J.split_edge_upper_le _ _ _).trans hJ]
end

lemma box_additive_on_integral_Henstock' [fintype Œπ]
  (H : ‚àÄ J ‚â§ I, integrable J Henstock' volume f) :
  box_additive_on (Œª J, integral J Henstock' volume f) I :=
begin
  intros J hJ i x hx,
  set c := max (J.split_edge_lower i x hx).distortion (J.split_edge_upper i x hx).distortion,
  haveI : (Henstock'_aux c).ne_bot := Henstock'_aux_ne_bot (le_max_left _ _),
  haveI : (Henstock'_aux c).ne_bot := Henstock'_aux_ne_bot (le_max_right _ _),
  replace H : ‚àÄ J ‚â§ I, tendsto (integral_sum f volume) (Henstock'_aux c)
    (ùìù (integral J Henstock' volume f)) := Œª J hJ, tendsto_supr.1 ((H J hJ).has_integral.tendsto) c,
  have A := (H J hJ).comp (tendsto_union_Henstock'_aux hx c),
  simp only [(‚àò), integral_sum_union] at A,
  have B := H _ ((J.split_edge_lower_le _ _ hx).trans hJ),
  have C := H _ ((J.split_edge_upper_le _ _ hx).trans hJ),
  exact tendsto_nhds_unique ((B.comp tendsto_fst).add (C.comp tendsto_snd)) A
end

lemma Riemann'_integrable_of_continuous_on [fintype Œπ] [complete_space E]
  {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} (hc : continuous_on f I.Icc) :
  integrable I Riemann' volume f :=
begin
  have huc := (is_compact_pi_Icc I.lower I.upper).uniform_continuous_on_of_continuous hc,
  rw metric.uniform_continuous_on_iff_le at huc,
  refine (integrable_iff_ex_basis has_basis_Riemann').2 (Œª Œµ Œµ0, _),
  rcases huc (Œµ / I.volume) (div_pos Œµ0 I.volume_pos) with ‚ü®Œ¥, Œ¥0 : 0 < Œ¥, HŒ¥‚ü©,
  use [Œ¥ / 2, half_pos Œ¥0],
  rintros œÄ‚ÇÅ œÄ‚ÇÇ h‚ÇÅ h‚ÇÇ,
  simp_rw [integral_sum_sub_partitions _ _ (box_additive_on_volume I),
    ‚Üê continuous_linear_map.map_sub, partition.finsum_eq_sum, volume_apply],
  have : ‚àÄ J ‚àà (œÄ‚ÇÅ.to_partition ‚äì œÄ‚ÇÇ.to_partition).finite_boxes.to_finset,
    ‚à•(J : _).volume ‚Ä¢ (f ((œÄ‚ÇÅ.inf_unmarked œÄ‚ÇÇ.to_partition).mark J) -
      f ((œÄ‚ÇÇ.inf_unmarked œÄ‚ÇÅ.to_partition).mark J))‚à• ‚â§ J.volume * (Œµ / I.volume),
  { intros J hJ,
    rw [finite.mem_to_finset] at hJ,
    rw [norm_smul, real.norm_eq_abs, abs_of_pos J.volume_pos, mul_le_mul_left J.volume_pos,
      ‚Üê dist_eq_norm],
    refine HŒ¥ _ _ (marked_partition.mark_mem_Icc _ _) (marked_partition.mark_mem_Icc _ _) _,
    rw [‚Üê add_halves Œ¥],
    refine (dist_triangle_left _ _ J.upper).trans (add_le_add (h‚ÇÅ _ _ _) (h‚ÇÇ _ _ _)),
    { apply partition.bUnion_index_mem },
    { exact (@box.Icc Œπ).monotone (partition.le_bUnion_index _ hJ) J.upper_mem_Icc },
    { apply partition.bUnion_index_mem },
    { rw inf_comm at hJ,
      exact (@box.Icc Œπ).monotone (partition.le_bUnion_index _ hJ) J.upper_mem_Icc } },
  refine (norm_sum_le_of_le _ this).trans _,
  rw [‚Üê finset.sum_mul, ‚Üê partition.finsum_eq_sum,
    (box_additive_on_box_volume I).finsum_mem_partition, mul_div_cancel' _ I.volume_pos.ne']
end

lemma Henstock_integrable_of_continuous_on [fintype Œπ] [complete_space E]
  {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} (hc : continuous_on f I.Icc) :
  integrable I Henstock volume f :=
(Riemann'_integrable_of_continuous_on hc).R'_to_MS.MS_to_H

lemma Henstock'_integrable_of_continuous_on [fintype Œπ] [complete_space E]
  {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} (hc : continuous_on f I.Icc) :
  integrable I Henstock' volume f :=
(Henstock_integrable_of_continuous_on hc).H_to_H'

lemma has_integral_McShane_inf_principal_of_forall_is_o [fintype Œπ] (B : box Œπ ‚Üí ‚Ñù)
  (HB : box_additive_on B I) (g : box Œπ ‚Üí F) (hg : box_additive_on g I) (p : (Œπ ‚Üí ‚Ñù) ‚Üí box Œπ ‚Üí Prop)
  (H : ‚àÄ (x ‚àà I.Icc) (Œµ > 0), ‚àÉ Œ¥ > 0, ‚àÄ J ‚â§ I, J.Icc ‚äÜ metric.closed_ball x Œ¥ ‚Üí p x J ‚Üí
    dist (vol J (f x)) (g J) ‚â§ Œµ * B J) :
  has_integral I (McShane ‚äì ùìü {œÄ | ‚àÄ J ‚àà œÄ, p (œÄ.mark J) J}) vol f (g I) :=
begin
  refine ((has_basis_McShane.inf_principal _).tendsto_iff metric.nhds_basis_closed_ball).2 _,
  intros Œµ Œµ0,
  choose! Œ¥ Œ¥0 HŒ¥Œµ using H, simp only [dist_eq_norm] at HŒ¥Œµ,
  have Hpos : 0 < max (B I) 1, from lt_max_iff.2 (or.inr zero_lt_one),
  refine ‚ü®Œª x, Œ¥ x (Œµ / max (B I) 1), Œª x hx, Œ¥0 x hx _ (div_pos Œµ0 Hpos), _‚ü©,
  rintro œÄ ‚ü®hœÄŒ¥, hœÄp‚ü©, rw mem_set_of_eq at hœÄŒ¥ hœÄp,
  erw [metric.mem_closed_ball, ‚Üê hg.finsum_mem_partition œÄ.to_partition, dist_eq_norm, integral_sum,
   œÄ.to_partition.finsum_eq_sum, œÄ.to_partition.finsum_eq_sum, ‚Üê finset.sum_sub_distrib],
  have : ‚àÄ J ‚àà œÄ.finite_boxes.to_finset, ‚à•vol J (f $ œÄ.mark J) - g J‚à• ‚â§ Œµ / max (B I) 1 * B J,
  { intros J hJ,
    rw finite.mem_to_finset at hJ,
    exact HŒ¥Œµ _ (œÄ.mark_mem_Icc _) _ (div_pos Œµ0 Hpos) _ (œÄ.to_partition.le_of_mem hJ) (hœÄŒ¥ J hJ)
      (hœÄp _ hJ) },
  refine (norm_sum_le_of_le _ this).trans _,
  rw [‚Üê finset.mul_sum, ‚Üê œÄ.to_partition.finsum_eq_sum, HB.finsum_mem_partition],
  rw [div_mul_eq_mul_div, div_le_iff Hpos],
  exact mul_le_mul_of_nonneg_left (le_max_left _ _) Œµ0.le
end

lemma has_integral_Henstock'_of_forall_is_o [fintype Œπ] (B : box Œπ ‚Üí ‚Ñù) (HB : box_additive_on B I)
  (g : box Œπ ‚Üí F) (hg : box_additive_on g I)
  (H : ‚àÄ (c : ‚Ñù‚â•0) (x ‚àà I.Icc) (Œµ > 0), ‚àÉ Œ¥ > 0, ‚àÄ J ‚â§ I, J.Icc ‚äÜ metric.closed_ball x Œ¥ ‚Üí
    x ‚àà J.Icc ‚Üí J.distortion ‚â§ c ‚Üí dist (vol J (f x)) (g J) ‚â§ Œµ * B J) :
  has_integral I Henstock' vol f (g I) :=
begin
  rw [Henstock'_def, has_integral, tendsto_supr],
  intro c, rw ‚Üê has_integral,
  convert has_integral_McShane_inf_principal_of_forall_is_o B HB g hg
    (Œª x J, x ‚àà J.Icc ‚àß J.distortion ‚â§ c) _,
  simpa only [and_imp] using H c
end

end box_integral
