import analysis.box_integral.partition.filter
import analysis.box_integral.partition.additive
import analysis.normed_space.operator_norm
import topology.uniform_space.compact_separated

open_locale big_operators classical topological_space nnreal filter
open set finset function filter

noncomputable theory

namespace box_integral

universes u v w

variables {Œπ : Type u} {E : Type v} {F : Type w} [normed_group E] [normed_space ‚Ñù E]
  [normed_group F] [normed_space ‚Ñù F] {I J : box Œπ} {œÄ : tagged_partition I}

namespace partition

def union {I : box Œπ} {i : Œπ} {x : ‚Ñù} {hl : I.lower i < x} {hu : x < I.upper i}
  (œÄ‚ÇÅ : partition ((I.split_lower i x).get hl)) (œÄ‚ÇÇ : partition ((I.split_upper i x).get hu)) :
  partition I :=
(split I i x).bUnion $ update (update (Œª J, ‚ä§) _ œÄ‚ÇÅ) _ œÄ‚ÇÇ

variables {i : Œπ} {x : ‚Ñù} {hl : I.lower i < x} {hu : x < I.upper i}
  {œÄ‚ÇÅ : partition ((I.split_lower i x).get hl)} {œÄ‚ÇÇ : partition ((I.split_upper i x).get hu)}

@[simp] lemma mem_union : J ‚àà œÄ‚ÇÅ.union œÄ‚ÇÇ ‚Üî J ‚àà œÄ‚ÇÅ ‚à® J ‚àà œÄ‚ÇÇ :=
by simp only [‚Üê mem_boxes, union, bUnion_boxes, finset.mem_bUnion, exists_prop,
  split_boxes_of_mem_Ioo ‚ü®hl, hu‚ü©, finset.mem_insert, finset.mem_singleton,
  or_and_distrib_right, exists_or_distrib, exists_eq_left, update_same,
  update_noteq (box.split_lower_get_ne_split_upper_get _ _)]

variables (œÄ‚ÇÅ œÄ‚ÇÇ)

@[simp] lemma union_boxes : (œÄ‚ÇÅ.union œÄ‚ÇÇ).boxes = œÄ‚ÇÅ.boxes ‚à™ œÄ‚ÇÇ.boxes :=
finset.ext $ Œª y, mem_union.trans finset.mem_union.symm

lemma sum_union_boxes {M : Type*} [add_comm_monoid M] (f : box Œπ ‚Üí M) :
  ‚àë J in (œÄ‚ÇÅ.union œÄ‚ÇÇ).boxes, f J = ‚àë J in œÄ‚ÇÅ.boxes, f J + ‚àë J in œÄ‚ÇÇ.boxes, f J :=
begin
  rw [union_boxes, finset.sum_union],
  exact disjoint_boxes_of_disjoint
    (box.disjoint_of_mem_split_lower_of_mem_split_upper (part.get_mem _) (part.get_mem _)) _ _
end

end partition

namespace tagged_partition

variables {i : Œπ} {x : ‚Ñù} {hl : I.lower i < x} {hu : x < I.upper i}

@[simps { attrs := [], fully_applied := false }]
def union (œÄ‚ÇÅ : tagged_partition ((I.split_lower i x).get hl))
  (œÄ‚ÇÇ : tagged_partition ((I.split_upper i x).get hu)) :
  tagged_partition I :=
{ to_partition := œÄ‚ÇÅ.to_partition.union œÄ‚ÇÇ.to_partition,
  tag := Œª J, if J ‚àà œÄ‚ÇÅ then œÄ‚ÇÅ.tag J else œÄ‚ÇÇ.tag J,
  tag_mem_Icc := Œª J,
    begin
      split_ifs,
      exacts [box.le_iff_Icc.1 I.split_lower_get_le (œÄ‚ÇÅ.tag_mem_Icc _),
        box.le_iff_Icc.1 I.split_upper_get_le (œÄ‚ÇÇ.tag_mem_Icc _)]
    end }

variables {œÄ‚ÇÅ : tagged_partition ((I.split_lower i x).get hl)}
  {œÄ‚ÇÇ : tagged_partition ((I.split_upper i x).get hu)}

@[simp] lemma mem_union {J : box Œπ} : J ‚àà œÄ‚ÇÅ.union œÄ‚ÇÇ ‚Üî J ‚àà œÄ‚ÇÅ ‚à® J ‚àà œÄ‚ÇÇ := partition.mem_union

lemma is_subordinate.union [fintype Œπ] {r : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñù} (h‚ÇÅ : is_subordinate œÄ‚ÇÅ r)
  (h‚ÇÇ : is_subordinate œÄ‚ÇÇ r) :
  is_subordinate (œÄ‚ÇÅ.union œÄ‚ÇÇ) r :=
begin
  intros J hJ, rw mem_union at hJ,
  by_cases hJ‚ÇÅ : J ‚àà œÄ‚ÇÅ,
  { simp only [union, if_pos hJ‚ÇÅ, h‚ÇÅ J hJ‚ÇÅ] },
  { simp only [union, if_neg hJ‚ÇÅ, h‚ÇÇ J (hJ.resolve_left hJ‚ÇÅ)] }
end

lemma is_Henstock.union
  (h‚ÇÅ : is_Henstock œÄ‚ÇÅ) (h‚ÇÇ : is_Henstock œÄ‚ÇÇ) :
  is_Henstock (œÄ‚ÇÅ.union œÄ‚ÇÇ) :=
begin
  intros J hJ, rw mem_union at hJ,
  by_cases hJ‚ÇÅ : J ‚àà œÄ‚ÇÅ,
  { simp only [union, if_pos hJ‚ÇÅ, h‚ÇÅ J hJ‚ÇÅ] },
  { simp only [union, if_neg hJ‚ÇÅ, h‚ÇÇ J (hJ.resolve_left hJ‚ÇÅ)] }
end

variables (hl hu)

lemma tendsto_union_Henstock [fintype Œπ] :
  tendsto (Œª œÄ : tagged_partition ((I.split_lower i x).get hl) √ó
    tagged_partition ((I.split_upper i x).get hu), œÄ.1.union œÄ.2)
    (Henstock √ó·∂† Henstock) Henstock :=
begin
  refine ((has_basis_Henstock.prod has_basis_Henstock).tendsto_iff has_basis_Henstock).2 _,
  refine Œª r hr, ‚ü®(r, r), ‚ü®Œª x hx, hr x _, Œª x hx, hr x _‚ü©, _‚ü©,
  { exact box.le_iff_Icc.1 I.split_lower_get_le hx },
  { exact box.le_iff_Icc.1 I.split_upper_get_le hx },
  { rintro ‚ü®œÄ‚ÇÅ, œÄ‚ÇÇ‚ü© ‚ü®‚ü®h‚ÇÅr, h‚ÇÅ‚ü©, ‚ü®h‚ÇÇr, h‚ÇÇ‚ü©‚ü©,
    exact ‚ü®h‚ÇÅr.union h‚ÇÇr, h‚ÇÅ.union h‚ÇÇ‚ü© }
end

lemma tendsto_union_Henstock'_aux [fintype Œπ] (c : ‚Ñù‚â•0) :
  tendsto (Œª œÄ : tagged_partition ((I.split_lower i x).get hl) √ó
    tagged_partition ((I.split_upper i x).get hu), œÄ.1.union œÄ.2)
    (Henstock'_aux c √ó·∂† Henstock'_aux c) (Henstock'_aux c) :=
begin
  rw [Henstock'_aux, Henstock'_aux, ‚Üê prod_inf_prod, prod_principal_principal],
  refine (tendsto_union_Henstock hl hu).inf (tendsto_principal_principal.2 _),
  simp only [mem_union, mem_set_of_eq],
  rintro ‚ü®œÄ‚ÇÅ, œÄ‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© J (hJ|hJ),
  exacts [h‚ÇÅ J hJ, h‚ÇÇ J hJ]
end

lemma tendsto_union_Riemann [fintype Œπ] :
  tendsto (Œª œÄ : tagged_partition ((I.split_lower i x).get hl) √ó
    tagged_partition ((I.split_upper i x).get hu), œÄ.1.union œÄ.2)
    (Riemann √ó·∂† Riemann) Riemann :=
begin
  refine ((has_basis_Riemann.prod has_basis_Riemann).tendsto_iff has_basis_Riemann).2 _,
  refine Œª r hr, ‚ü®(r, r), ‚ü®hr, hr‚ü©, _‚ü©,
  rintro ‚ü®œÄ‚ÇÅ, œÄ‚ÇÇ‚ü© ‚ü®‚ü®h‚ÇÅr, h‚ÇÅ‚ü©, ‚ü®h‚ÇÇr, h‚ÇÇ‚ü©‚ü©,
  exact ‚ü®h‚ÇÅr.union h‚ÇÇr, h‚ÇÅ.union h‚ÇÇ‚ü©
end

end tagged_partition

open tagged_partition

def integral_sum (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F))
  (œÄ : tagged_partition I) : F :=
‚àë J in œÄ.boxes, vol J (f (œÄ.tag J))

@[simp] lemma integral_sum_add (f g : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F))
  (œÄ : tagged_partition I) :
  integral_sum (f + g) vol œÄ = integral_sum f vol œÄ + integral_sum g vol œÄ :=
by simp only [integral_sum, pi.add_apply, (vol _).map_add, finset.sum_add_distrib]

@[simp] lemma integral_sum_neg (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F))
  (œÄ : tagged_partition I) :
  integral_sum (-f) vol œÄ = -integral_sum f vol œÄ :=
by simp only [integral_sum, pi.neg_apply, (vol _).map_neg, finset.sum_neg_distrib]

@[simp] lemma integral_sum_smul (c : ‚Ñù) (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F))
  (œÄ : tagged_partition I) :
  integral_sum (c ‚Ä¢ f) vol œÄ = c ‚Ä¢ integral_sum f vol œÄ :=
by simp only [integral_sum, finset.smul_sum, pi.smul_apply, continuous_linear_map.map_smul]

def has_integral (I : box Œπ) (l : filter (tagged_partition I))
  (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F)) (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) (y : F) : Prop :=
tendsto (integral_sum f vol) l (ùìù y)

def integrable (I : box Œπ) (l : filter (tagged_partition I)) (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F))
  (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) : Prop :=
‚àÉ y, has_integral I l vol f y

def integral (I : box Œπ) (l : filter (tagged_partition I)) (vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F))
  (f : (Œπ ‚Üí ‚Ñù) ‚Üí E) : F :=
if h : integrable I l vol f then classical.some h else 0

variables {l : filter (tagged_partition I)}
  {f g : (Œπ ‚Üí ‚Ñù) ‚Üí E} {vol : box_additive_map Œπ (E ‚ÜíL[‚Ñù] F)} {y y' : F}

lemma has_integral.tendsto (h : has_integral I l vol f y) :
  tendsto (integral_sum f vol) l (ùìù y) := h

lemma integrable_iff_cauchy [complete_space F] [ne_bot l] :
  integrable I l vol f ‚Üî cauchy (l.map (integral_sum f vol)) :=
cauchy_map_iff_exists_tendsto.symm

lemma integrable_iff_ex_basis [complete_space F] [ne_bot l] {Œπ' : Sort*} {p : Œπ' ‚Üí Prop}
  {s : Œπ' ‚Üí set (tagged_partition I)} (h : has_basis l p s) :
  integrable I l vol f ‚Üî
    ‚àÄ Œµ > 0, ‚àÉ j (hi : p j), ‚àÄ œÄ‚ÇÅ œÄ‚ÇÇ ‚àà s j, ‚à•integral_sum f vol œÄ‚ÇÅ - integral_sum f vol œÄ‚ÇÇ‚à• ‚â§ Œµ :=
by simp only [integrable_iff_cauchy, cauchy_map_iff, ‚Äπne_bot l‚Ä∫, true_and,
  h.prod_self.tendsto_iff metric.uniformity_basis_dist_le, prod.forall, set.mem_prod, and_imp,
  mem_set_of_eq, dist_eq_norm, gt_iff_lt]

lemma has_integral.R'_to_R [fintype Œπ] (h : has_integral I Riemann' vol f y) :
  has_integral I Riemann vol f y :=
h.mono_left Riemann_le_Riemann'

lemma has_integral.R_to_H [fintype Œπ] (h : has_integral I Riemann vol f y) :
  has_integral I Henstock vol f y :=
h.mono_left Henstock_le_Riemann

lemma has_integral.R'_to_MS [fintype Œπ] (h : has_integral I Riemann' vol f y) :
  has_integral I McShane vol f y :=
h.mono_left McShane_le_Riemann'

lemma has_integral.MS_to_H [fintype Œπ] (h : has_integral I McShane vol f y) :
  has_integral I Henstock vol f y :=
h.mono_left Henstock_le_McShane

lemma has_integral.H_to_H' [fintype Œπ] (h : has_integral I Henstock vol f y) :
  has_integral I Henstock' vol f y :=
h.mono_left Henstock'_le_Henstock

lemma integrable.has_integral (h : integrable I l vol f) :
  has_integral I l vol f (integral I l vol f) :=
by { rw [integral, dif_pos h], exact classical.some_spec h }

lemma integrable.mono {l'} (h : integrable I l vol f) (hle : l' ‚â§ l) : integrable I l' vol f :=
‚ü®_, h.has_integral.mono_left hle‚ü©

lemma integrable.R'_to_R [fintype Œπ] (h : integrable I Riemann' vol f) :
  integrable I Riemann vol f :=
h.mono Riemann_le_Riemann'

lemma integrable.R_to_H [fintype Œπ] (h : integrable I Riemann vol f) :
  integrable I Henstock vol f :=
h.mono Henstock_le_Riemann

lemma integrable.R'_to_MS [fintype Œπ] (h : integrable I Riemann' vol f) :
  integrable I McShane vol f :=
h.mono McShane_le_Riemann'

lemma integrable.MS_to_H [fintype Œπ] (h : integrable I McShane vol f) :
  integrable I Henstock vol f :=
h.mono Henstock_le_McShane

lemma integrable.H_to_H' [fintype Œπ] (h : integrable I Henstock vol f) :
  integrable I Henstock' vol f :=
h.mono Henstock'_le_Henstock

lemma has_integral.unique [ne_bot l] (h : has_integral I l vol f y)
  (h' : has_integral I l vol f y') :
  y = y' :=
tendsto_nhds_unique h h'

lemma has_integral.integrable (h : has_integral I l vol f y) : integrable I l vol f := ‚ü®_, h‚ü©

lemma has_integral.integral_eq [ne_bot l] (h : has_integral I l vol f y) :
  integral I l vol f = y :=
h.integrable.has_integral.unique h

lemma has_integral.add (h : has_integral I l vol f y) (h' : has_integral I l vol g y') :
  has_integral I l vol (f + g) (y + y') :=
by simpa only [has_integral, ‚Üê integral_sum_add] using h.add h'

lemma integrable.add (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integrable I l vol (f + g) :=
(hf.has_integral.add hg.has_integral).integrable

lemma integral_add [ne_bot l] (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integral I l vol (f + g) = integral I l vol f + integral I l vol g :=
(hf.has_integral.add hg.has_integral).integral_eq

lemma has_integral.neg (hf : has_integral I l vol f y) : has_integral I l vol (-f) (-y) :=
by simpa only [has_integral, ‚Üê integral_sum_neg] using hf.neg

lemma integrable.neg (hf : integrable I l vol f) : integrable I l vol (-f) :=
hf.has_integral.neg.integrable

lemma integrable.of_neg (hf : integrable I l vol (-f)) : integrable I l vol f := neg_neg f ‚ñ∏ hf.neg

@[simp] lemma integrable_neg : integrable I l vol (-f) ‚Üî integrable I l vol f :=
‚ü®Œª h, h.of_neg, Œª h, h.neg‚ü©

@[simp] lemma integral_neg [ne_bot l] : integral I l vol (-f) = -integral I l vol f :=
if h : integrable I l vol f then h.has_integral.neg.integral_eq
else by rw [integral, integral, dif_neg h, dif_neg (mt integrable.of_neg h), neg_zero]

lemma has_integral.sub (h : has_integral I l vol f y) (h' : has_integral I l vol g y') :
  has_integral I l vol (f - g) (y - y') :=
by simpa only [sub_eq_add_neg] using h.add h'.neg

lemma integrable.sub (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integrable I l vol (f - g) :=
(hf.has_integral.sub hg.has_integral).integrable

lemma integral_sub [ne_bot l] (hf : integrable I l vol f) (hg : integrable I l vol g) :
  integral I l vol (f - g) = integral I l vol f - integral I l vol g :=
(hf.has_integral.sub hg.has_integral).integral_eq

lemma has_integral_zero : has_integral I l vol (Œª _, (0:E)) 0 :=
by { dunfold has_integral, convert tendsto_const_nhds, ext œÄ, simp [integral_sum] }

lemma integrable_zero : integrable I l vol (Œª _, (0:E)) := ‚ü®0, has_integral_zero‚ü©

@[simp] lemma integral_zero [ne_bot l] : integral I l vol (Œª _, (0:E)) = 0 :=
has_integral_zero.integral_eq

lemma has_integral_sum {Œ± : Type*} {s : finset Œ±} {f : Œ± ‚Üí (Œπ ‚Üí ‚Ñù) ‚Üí E} {g : Œ± ‚Üí F}
  (h : ‚àÄ i ‚àà s, has_integral I l vol (f i) (g i)) :
  has_integral I l vol (Œª x, ‚àë i in s, f i x) (‚àë i in s, g i) :=
begin
  induction s using finset.induction_on with a s ha ihs, { simp [has_integral_zero] },
  simp only [finset.sum_insert ha], rw finset.forall_mem_insert at h,
  exact h.1.add (ihs h.2)
end

lemma has_integral.smul (hf : has_integral I l vol f y) (c : ‚Ñù) :
  has_integral I l vol (c ‚Ä¢ f) (c ‚Ä¢ y) :=
by simpa only [has_integral, ‚Üê integral_sum_smul]
  using (tendsto_const_nhds : tendsto _ _ (ùìù c)).smul hf

lemma integrable.smul (hf : integrable I l vol f) (c : ‚Ñù) :
  integrable I l vol (c ‚Ä¢ f) :=
(hf.has_integral.smul c).integrable

lemma integrable.of_smul {c : ‚Ñù} (hf : integrable I l vol (c ‚Ä¢ f)) (hc : c ‚â† 0) :
  integrable I l vol f :=
by { convert hf.smul c‚Åª¬π, ext x, simp only [pi.smul_apply, inv_smul_smul' hc] }

@[simp] lemma integral_smul [ne_bot l] (c : ‚Ñù) :
  integral I l vol (Œª x, c ‚Ä¢ f x) = c ‚Ä¢ integral I l vol f :=
begin
  rcases eq_or_ne c 0 with rfl | hc, { simp },
  by_cases hf : integrable I l vol f,
  { exact (hf.has_integral.smul c).integral_eq },
  { have : ¬¨integrable I l vol (Œª x, c ‚Ä¢ f x), from mt (Œª h, h.of_smul hc) hf,
    rw [integral, integral, dif_neg hf, dif_neg this, smul_zero] }
end

lemma integral_sum_bUnion_partition [fintype Œπ] (œÄ : tagged_partition I) (œÄi : Œ† J, partition J) :
  integral_sum f vol (œÄ.bUnion_partition œÄi) = integral_sum f vol œÄ :=
begin
  refine (œÄ.to_partition.sum_bUnion_boxes œÄi _).trans _,
  refine finset.sum_congr rfl (Œª J hJ, _),
  calc ‚àë J' in (œÄi J).boxes, vol J' (f (œÄ.tag (œÄ.to_partition.bUnion_index œÄi J')))
      = ‚àë J' in (œÄi J).boxes, vol J' (f (œÄ.tag J)) :
    finset.sum_congr rfl (Œª J' hJ', by rw partition.bUnion_index_of_mem _ hJ hJ')
  ... = vol J (f (œÄ.tag J)) :
    (vol.map ‚ü®Œª g : E ‚ÜíL[‚Ñù] F, g (f (œÄ.tag J)), Œª g‚ÇÅ g‚ÇÇ, rfl‚ü©).sum_partition_boxes (œÄi J)
end

lemma integral_sum_inf_partition [fintype Œπ] (œÄ : tagged_partition I) (œÄ' : partition I) :
  integral_sum f vol (œÄ.inf_partition œÄ') = integral_sum f vol œÄ :=
integral_sum_bUnion_partition œÄ _

lemma integral_sum_bUnion_tagged [fintype Œπ] (œÄ : partition I) (œÄi : Œ† J, tagged_partition J) :
  integral_sum f vol (œÄ.bUnion_tagged œÄi) = ‚àë J in œÄ.boxes, integral_sum f vol (œÄi J) :=
begin
  refine (œÄ.sum_bUnion_boxes _ _).trans (finset.sum_congr rfl $ Œª J hJ,
    finset.sum_congr rfl $ Œª J' hJ', _),
  simp only [partition.bUnion_tagged],
  rw œÄ.bUnion_index_of_mem hJ hJ'
end

lemma integral_sum_bUnion_tagged_update [fintype Œπ] {œÄ : partition I} (œÄi : Œ† J, tagged_partition J)
  {J : box Œπ} (hJ : J ‚àà œÄ) (œÄJ : tagged_partition J) :
  integral_sum f vol (œÄ.bUnion_tagged (update œÄi J œÄJ)) =
    integral_sum f vol (œÄ.bUnion_tagged œÄi) - integral_sum f vol (œÄi J) + integral_sum f vol œÄJ :=
begin
  rw [integral_sum_bUnion_tagged, integral_sum_bUnion_tagged,
    sum_eq_sum_diff_singleton_add hJ, sum_eq_add_sum_diff_singleton hJ,
    add_sub_cancel', update_same],
  refine congr_arg2 (+) (sum_congr rfl $ Œª J' hJ', _) rfl,
  rw [mem_sdiff, finset.mem_singleton] at hJ',
  rw update_noteq hJ'.2
end

@[simp] lemma integral_sum_union {i : Œπ} {x : ‚Ñù} {hl : I.lower i < x} {hu : x < I.upper i}
  (œÄ‚ÇÅ : tagged_partition ((I.split_lower i x).get hl))
  (œÄ‚ÇÇ : tagged_partition ((I.split_upper i x).get hu)) :
  integral_sum f vol (œÄ‚ÇÅ.union œÄ‚ÇÇ) = integral_sum f vol œÄ‚ÇÅ + integral_sum f vol œÄ‚ÇÇ :=
begin
  refine (partition.sum_union_boxes _ _ _).trans _,
  refine congr_arg2 (+) (finset.sum_congr rfl $ Œª J hJ, _) (finset.sum_congr rfl $ Œª J hJ, _),
  { simp only [union_tag, if_pos (show J ‚àà œÄ‚ÇÅ, from hJ)] },
  { suffices : J ‚àâ œÄ‚ÇÅ, by simp only [union_tag, if_neg this],
    exact finset.disjoint_right.1 (partition.disjoint_boxes_of_disjoint
      (box.disjoint_split_lower_get_split_upper_get hl hu) _ _) hJ }
end

lemma integral_sum_sub_partitions [fintype Œπ] (œÄ‚ÇÅ œÄ‚ÇÇ : tagged_partition I) :
  integral_sum f vol œÄ‚ÇÅ - integral_sum f vol œÄ‚ÇÇ =
    ‚àë J in (œÄ‚ÇÅ.to_partition ‚äì œÄ‚ÇÇ.to_partition).boxes,
      (vol J (f $ (œÄ‚ÇÅ.inf_partition œÄ‚ÇÇ.to_partition).tag J) -
        vol J (f $ (œÄ‚ÇÇ.inf_partition œÄ‚ÇÅ.to_partition).tag J)) :=
begin
  rw [‚Üê integral_sum_inf_partition œÄ‚ÇÅ œÄ‚ÇÇ.to_partition,
    ‚Üê integral_sum_inf_partition œÄ‚ÇÇ œÄ‚ÇÅ.to_partition, integral_sum, integral_sum,
    finset.sum_sub_distrib],
  simp only [inf_partition_to_partition, inf_comm]
end

lemma has_integral_const [fintype Œπ] (c : E) : has_integral I l vol (Œª _, c) (vol I c) :=
tendsto_const_nhds.congr $ Œª œÄ,
  ((vol.map ‚ü®Œª g : E ‚ÜíL[‚Ñù] F, g c, Œª _ _, rfl‚ü©).sum_partition_boxes _).symm

lemma integral_const [fintype Œπ] [ne_bot l] (c : E) :
  integral I l vol (Œª _, c) = vol I c :=
(has_integral_const c).integral_eq

lemma integrable_const [fintype Œπ] (c : E) :
  integrable I l vol (Œª _, c) :=
‚ü®_, has_integral_const c‚ü©

def volume [fintype Œπ] : box_additive_map Œπ (E ‚ÜíL[‚Ñù] E) :=
box.volume.map { .. continuous_linear_map.lsmul ‚Ñù ‚Ñù}

@[simp] lemma volume_apply [fintype Œπ] (I : box Œπ) (x : E) : volume I x = I.volume ‚Ä¢ x := rfl

lemma norm_integral_le_of_le_const [fintype Œπ] [ne_bot l] {c : ‚Ñù} (hc : ‚àÄ x ‚àà I.Icc, ‚à•f x‚à• ‚â§ c) :
  ‚à•(integral I l (@volume Œπ E _ _ _) f : E)‚à• ‚â§ I.volume * c :=
begin
  have h0 : 0 ‚â§ c, from (norm_nonneg _).trans (hc I.upper I.upper_mem_Icc),
  by_cases hf : @integrable Œπ E E _ _ _ _ I l volume f,
  { refine le_of_tendsto' hf.has_integral.norm (Œª œÄ, _),
    rw [integral_sum],
    rw [‚Üê box.volume.sum_partition_boxes œÄ.to_partition, finset.sum_mul],
    refine norm_sum_le_of_le _ (Œª J hJ, _),
    rw [volume_apply, norm_smul, real.norm_eq_abs, abs_of_pos J.volume_pos,
      mul_le_mul_left J.volume_pos],
    exact hc _ (œÄ.tag_mem_Icc _) },
  { rw [integral, dif_neg hf, norm_zero],
    exact mul_nonneg I.volume_pos.le h0 }
end

lemma integrable.to_subbox_Riemann [fintype Œπ] [complete_space E]
  (h : @integrable Œπ E E _ _ _ _ I Riemann volume f) (hJ : J ‚â§ I) :
  @integrable Œπ E E _ _ _ _ J Riemann volume f :=
begin
  refine (integrable_iff_ex_basis has_basis_Riemann).2 (Œª Œµ Œµ0, _),
  rcases partition.exists_partition_mem hJ with ‚ü®œÄ, hœÄ‚ü©,
  rcases (integrable_iff_ex_basis has_basis_Riemann).1 h Œµ Œµ0 with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©,
  use [Œ¥, Œ¥0], rintro œÄ‚ÇÅ œÄ‚ÇÇ ‚ü®h‚ÇÅŒ¥, h‚ÇÅH‚ü© ‚ü®h‚ÇÇŒ¥, h‚ÇÇH‚ü©,
  have := Œª J : box Œπ, exists_is_Henstock_is_subordinate_homothetic J (Œª _ _, Œ¥0),
  choose œÄi hœÄiH hœÄiŒ¥ H, clear H,
  convert HŒ¥ (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÅ)) (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÇ)) _ _ using 2,
  { simp [integral_sum_bUnion_tagged_update _ hœÄ] },
  { exact ‚ü®(is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÅŒ¥, Œª _ _ _, hœÄiŒ¥ _‚ü©,
      (is_Henstock_bUnion_update hœÄ _).2 ‚ü®h‚ÇÅH, Œª _ _ _, hœÄiH _‚ü©‚ü© },
  { exact ‚ü®(is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÇŒ¥, Œª _ _ _, hœÄiŒ¥ _‚ü©,
      (is_Henstock_bUnion_update hœÄ _).2 ‚ü®h‚ÇÇH, Œª _ _ _, hœÄiH _‚ü©‚ü© }
end

lemma integrable.to_subbox_Riemann' [fintype Œπ] [complete_space E]
  (h : @integrable Œπ E E _ _ _ _ I Riemann' volume f) (hJ : J ‚â§ I) :
  @integrable Œπ E E _ _ _ _ J Riemann' volume f :=
begin
  refine (integrable_iff_ex_basis has_basis_Riemann').2 (Œª Œµ Œµ0, _),
  rcases partition.exists_partition_mem hJ with ‚ü®œÄ, hœÄ‚ü©,
  rcases (integrable_iff_ex_basis has_basis_Riemann').1 h Œµ Œµ0 with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©,
  use [Œ¥, Œ¥0], rintro œÄ‚ÇÅ œÄ‚ÇÇ h‚ÇÅŒ¥ h‚ÇÇŒ¥,
  have := Œª J : box Œπ, exists_is_Henstock_is_subordinate_homothetic J (Œª _ _, Œ¥0),
  choose œÄi hœÄiH hœÄiŒ¥ H, clear H,
  convert HŒ¥ (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÅ)) (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÇ)) _ _ using 2,
  { simp [integral_sum_bUnion_tagged_update _ hœÄ] },
  { exact (is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÅŒ¥, Œª _ _ _, hœÄiŒ¥ _‚ü© },
  { exact (is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÇŒ¥, Œª _ _ _, hœÄiŒ¥ _‚ü© }
end

lemma integrable.to_subbox_McShane [fintype Œπ] [complete_space E]
  (h : @integrable Œπ E E _ _ _ _ I McShane volume f) (hJ : J ‚â§ I) :
  @integrable Œπ E E _ _ _ _ J McShane volume f :=
begin
  refine (integrable_iff_ex_basis has_basis_McShane).2 (Œª Œµ Œµ0, _),
  rcases partition.exists_partition_mem hJ with ‚ü®œÄ, hœÄ‚ü©,
  rcases (integrable_iff_ex_basis has_basis_McShane).1 h Œµ Œµ0 with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©,
  refine ‚ü®Œ¥, Œª x hx, Œ¥0 x (box.le_iff_Icc.1 hJ hx), _‚ü©, rintro œÄ‚ÇÅ œÄ‚ÇÇ h‚ÇÅŒ¥ h‚ÇÇŒ¥,
  have := Œª (J : box Œπ) (hJ : J ‚â§ I),
    exists_is_Henstock_is_subordinate_homothetic J (Œª x hx, Œ¥0 x (box.le_iff_Icc.1 hJ hx)),
  choose! œÄi hœÄiH hœÄiŒ¥ H, clear H,
  convert HŒ¥ (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÅ)) (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÇ)) _ _ using 2,
  { simp [integral_sum_bUnion_tagged_update _ hœÄ] },
  { exact (is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÅŒ¥, Œª J' hJ' _, hœÄiŒ¥ _ (œÄ.le_of_mem hJ')‚ü© },
  { exact (is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÇŒ¥, Œª J' hJ' _, hœÄiŒ¥ _ (œÄ.le_of_mem hJ')‚ü© }
end

lemma integrable.to_subbox_Henstock [fintype Œπ] [complete_space E]
  (h : @integrable Œπ E E _ _ _ _ I Henstock volume f) (hJ : J ‚â§ I) :
  @integrable Œπ E E _ _ _ _ J Henstock volume f :=
begin
  refine (integrable_iff_ex_basis has_basis_Henstock).2 (Œª Œµ Œµ0, _),
  rcases partition.exists_partition_mem hJ with ‚ü®œÄ, hœÄ‚ü©,
  rcases (integrable_iff_ex_basis has_basis_Henstock).1 h Œµ Œµ0 with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©,
  refine ‚ü®Œ¥, Œª x hx, Œ¥0 x (box.le_iff_Icc.1 hJ hx), _‚ü©, rintro œÄ‚ÇÅ œÄ‚ÇÇ ‚ü®h‚ÇÅŒ¥, h‚ÇÅH‚ü© ‚ü®h‚ÇÇŒ¥, h‚ÇÇH‚ü©,
  have := Œª (J : box Œπ) (hJ : J ‚â§ I),
    exists_is_Henstock_is_subordinate_homothetic J (Œª x hx, Œ¥0 x (box.le_iff_Icc.1 hJ hx)),
  choose! œÄi hœÄiH hœÄiŒ¥ H, clear H,
  convert HŒ¥ (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÅ)) (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÇ)) _ _ using 2,
  { simp [integral_sum_bUnion_tagged_update _ hœÄ] },
  { exact ‚ü®(is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÅŒ¥, Œª J' hJ' _, hœÄiŒ¥ _ (œÄ.le_of_mem hJ')‚ü©,
      (is_Henstock_bUnion_update hœÄ _).2 ‚ü®h‚ÇÅH, Œª J' hJ' _, hœÄiH _ (œÄ.le_of_mem hJ')‚ü©‚ü© },
  { exact ‚ü®(is_subordinate_bUnion_update hœÄ _).2 ‚ü®h‚ÇÇŒ¥, Œª J' hJ' _, hœÄiŒ¥ _ (œÄ.le_of_mem hJ')‚ü©,
      (is_Henstock_bUnion_update hœÄ _).2 ‚ü®h‚ÇÇH, Œª J' hJ' _, hœÄiH _ (œÄ.le_of_mem hJ')‚ü©‚ü© }
end

lemma integrable.to_subbox_Henstock' [fintype Œπ] [complete_space E]
  (h : @integrable Œπ E E _ _ _ _ I Henstock' volume f) (hJ : J ‚â§ I) :
  @integrable Œπ E E _ _ _ _ J Henstock' volume f :=
begin
  refine (integrable_iff_ex_basis has_basis_Henstock').2 (Œª Œµ Œµ0, _),
  rcases partition.exists_partition_mem hJ with ‚ü®œÄ, hœÄ‚ü©,
  set C : ‚Ñù‚â•0 := œÄ.boxes.sup' œÄ.nonempty_boxes box.distortion,
  rcases (integrable_iff_ex_basis has_basis_Henstock'_antimono).1 h Œµ Œµ0 with ‚ü®Œ¥, ‚ü®Œ¥0, Œ¥_mono‚ü©, HŒ¥‚ü©,
  refine ‚ü®Œª c x, Œ¥ (max c C) x, Œª c x hx, Œ¥0 _ x (box.le_iff_Icc.1 hJ hx), _‚ü©,
  rintro œÄ‚ÇÅ œÄ‚ÇÇ ‚ü®c‚ÇÅ, h‚ÇÅŒ¥, h‚ÇÅH, hc‚ÇÅ‚ü© ‚ü®c‚ÇÇ, h‚ÇÇŒ¥, h‚ÇÇH, hc‚ÇÇ‚ü©,
  have := Œª (J : box Œπ) (hJ : J ‚â§ I), exists_is_Henstock_is_subordinate_homothetic J
    (Œª x hx, Œ¥0 (max (max c‚ÇÅ c‚ÇÇ) C) x (box.le_iff_Icc.1 hJ hx)),
  choose! œÄi hœÄiH hœÄiŒ¥ N hœÄiN,
  have hC : ‚àÄ (J ‚àà œÄ) (J' ‚àà œÄi J), box.distortion J' ‚â§ C,
  { intros J hJ J' hJ',
    rw box.distortion_eq_of_sub_eq_div (hœÄiN J (œÄ.le_of_mem hJ) J' hJ'),
    exact finset.le_sup' box.distortion hJ },
  convert HŒ¥ (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÅ)) (œÄ.bUnion_tagged (update œÄi J œÄ‚ÇÇ)) _ _ using 2,
  { simp [integral_sum_bUnion_tagged_update _ hœÄ] },
  { refine ‚ü®max c‚ÇÅ C, _, _, _‚ü©,
    { rw is_subordinate_bUnion_update hœÄ,
      exact ‚ü®h‚ÇÅŒ¥, Œª J' hJ' _, (hœÄiŒ¥ _ (œÄ.le_of_mem hJ')).mono
        (Œª x hx, Œ¥_mono (max_le_max (le_max_left c‚ÇÅ c‚ÇÇ) le_rfl) _)‚ü© },
    { rw is_Henstock_bUnion_update hœÄ,
      exact ‚ü®h‚ÇÅH, Œª J' hJ' _, hœÄiH _ (œÄ.le_of_mem hJ')‚ü© },
    { rw œÄ.forall_bUnion_tagged_update (Œª _ J', J'.distortion ‚â§ max c‚ÇÅ C) _ hœÄ,
      exact ‚ü®Œª J' hJ', (hc‚ÇÅ J' hJ').trans (le_max_left _ _),
        Œª J' hJ' _ J'' hJ'', (hC J' hJ' J'' hJ'').trans (le_max_right _ _)‚ü© } },
  { refine ‚ü®max c‚ÇÇ C, _, _, _‚ü©,
    { rw is_subordinate_bUnion_update hœÄ,
      exact ‚ü®h‚ÇÇŒ¥, Œª J' hJ' _, (hœÄiŒ¥ _ (œÄ.le_of_mem hJ')).mono
        (Œª x hx, Œ¥_mono (max_le_max (le_max_right c‚ÇÅ c‚ÇÇ) le_rfl) _)‚ü© },
    { rw is_Henstock_bUnion_update hœÄ,
      exact ‚ü®h‚ÇÇH, Œª J' hJ' _, hœÄiH _ (œÄ.le_of_mem hJ')‚ü© },
    { rw œÄ.forall_bUnion_tagged_update (Œª _ J', J'.distortion ‚â§ max c‚ÇÇ C) _ hœÄ,
      exact ‚ü®Œª J' hJ', (hc‚ÇÇ J' hJ').trans (le_max_left _ _),
        Œª J' hJ' _ J'' hJ'', (hC J' hJ' J'' hJ'').trans (le_max_right _ _)‚ü© } },
end

lemma box_additive_on_integral_Riemann [fintype Œπ]
  (H : ‚àÄ J ‚â§ I, @integrable Œπ E E _ _ _ _ J Riemann volume f) :
  box_additive_on (Œª J, integral J Riemann volume f) I :=
begin
  intros J hJ i x hx, simp only,
  have A := (H J hJ).has_integral.tendsto.comp (tendsto_union_Riemann hx),
  simp only [(‚àò), integral_sum_union] at A,
  have B := ((H (J.split_edge_lower i x hx) _).has_integral.tendsto.comp tendsto_fst).add
    ((H (J.split_edge_upper i x hx) _).has_integral.tendsto.comp tendsto_snd),
  exacts [tendsto_nhds_unique B A, (J.split_edge_lower_le _ _ _).trans hJ,
    (J.split_edge_upper_le _ _ _).trans hJ]
end

lemma box_additive_on_integral_Henstock [fintype Œπ]
  (H : ‚àÄ J ‚â§ I, integrable J Henstock volume f) :
  box_additive_on (Œª J, integral J Henstock volume f) I :=
begin
  intros J hJ i x hx,
  have A := (H J hJ).has_integral.tendsto.comp (tendsto_union_Henstock hx),
  simp only [(‚àò), integral_sum_union] at A,
  have B := ((H (J.split_edge_lower i x hx) _).has_integral.tendsto.comp tendsto_fst).add
    ((H (J.split_edge_upper i x hx) _).has_integral.tendsto.comp tendsto_snd),
  exacts [tendsto_nhds_unique B A, (J.split_edge_lower_le _ _ _).trans hJ,
    (J.split_edge_upper_le _ _ _).trans hJ]
end

lemma box_additive_on_integral_Henstock' [fintype Œπ]
  (H : ‚àÄ J ‚â§ I, integrable J Henstock' volume f) :
  box_additive_on (Œª J, integral J Henstock' volume f) I :=
begin
  intros J hJ i x hx,
  set c := max (J.split_edge_lower i x hx).distortion (J.split_edge_upper i x hx).distortion,
  haveI : (Henstock'_aux c).ne_bot := Henstock'_aux_ne_bot (le_max_left _ _),
  haveI : (Henstock'_aux c).ne_bot := Henstock'_aux_ne_bot (le_max_right _ _),
  replace H : ‚àÄ J ‚â§ I, tendsto (integral_sum f volume) (Henstock'_aux c)
    (ùìù (integral J Henstock' volume f)) := Œª J hJ, tendsto_supr.1 ((H J hJ).has_integral.tendsto) c,
  have A := (H J hJ).comp (tendsto_union_Henstock'_aux hx c),
  simp only [(‚àò), integral_sum_union] at A,
  have B := H _ ((J.split_edge_lower_le _ _ hx).trans hJ),
  have C := H _ ((J.split_edge_upper_le _ _ hx).trans hJ),
  exact tendsto_nhds_unique ((B.comp tendsto_fst).add (C.comp tendsto_snd)) A
end

lemma Riemann'_integrable_of_continuous_on [fintype Œπ] [complete_space E]
  {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} (hc : continuous_on f I.Icc) :
  integrable I Riemann' volume f :=
begin
  have huc := (is_compact_pi_Icc I.lower I.upper).uniform_continuous_on_of_continuous hc,
  rw metric.uniform_continuous_on_iff_le at huc,
  refine (integrable_iff_ex_basis has_basis_Riemann').2 (Œª Œµ Œµ0, _),
  rcases huc (Œµ / I.volume) (div_pos Œµ0 I.volume_pos) with ‚ü®Œ¥, Œ¥0 : 0 < Œ¥, HŒ¥‚ü©,
  use [Œ¥ / 2, half_pos Œ¥0],
  rintros œÄ‚ÇÅ œÄ‚ÇÇ h‚ÇÅ h‚ÇÇ,
  simp_rw [integral_sum_sub_partitions _ _ (box_additive_on_volume I),
    ‚Üê continuous_linear_map.map_sub, partition.finsum_eq_sum, volume_apply],
  have : ‚àÄ J ‚àà (œÄ‚ÇÅ.to_partition ‚äì œÄ‚ÇÇ.to_partition).finite_boxes.to_finset,
    ‚à•(J : _).volume ‚Ä¢ (f ((œÄ‚ÇÅ.inf_untagged œÄ‚ÇÇ.to_partition).tag J) -
      f ((œÄ‚ÇÇ.inf_untagged œÄ‚ÇÅ.to_partition).tag J))‚à• ‚â§ J.volume * (Œµ / I.volume),
  { intros J hJ,
    rw [finite.mem_to_finset] at hJ,
    rw [norm_smul, real.norm_eq_abs, abs_of_pos J.volume_pos, mul_le_mul_left J.volume_pos,
      ‚Üê dist_eq_norm],
    refine HŒ¥ _ _ (tagged_partition.tag_mem_Icc _ _) (tagged_partition.tag_mem_Icc _ _) _,
    rw [‚Üê add_halves Œ¥],
    refine (dist_triangle_left _ _ J.upper).trans (add_le_add (h‚ÇÅ _ _ _) (h‚ÇÇ _ _ _)),
    { apply partition.bUnion_index_mem },
    { exact (@box.Icc Œπ).monotone (partition.le_bUnion_index _ hJ) J.upper_mem_Icc },
    { apply partition.bUnion_index_mem },
    { rw inf_comm at hJ,
      exact (@box.Icc Œπ).monotone (partition.le_bUnion_index _ hJ) J.upper_mem_Icc } },
  refine (norm_sum_le_of_le _ this).trans _,
  rw [‚Üê finset.sum_mul, ‚Üê partition.finsum_eq_sum,
    (box_additive_on_box_volume I).finsum_mem_partition, mul_div_cancel' _ I.volume_pos.ne']
end

lemma Henstock_integrable_of_continuous_on [fintype Œπ] [complete_space E]
  {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} (hc : continuous_on f I.Icc) :
  integrable I Henstock volume f :=
(Riemann'_integrable_of_continuous_on hc).R'_to_MS.MS_to_H

lemma Henstock'_integrable_of_continuous_on [fintype Œπ] [complete_space E]
  {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} (hc : continuous_on f I.Icc) :
  integrable I Henstock' volume f :=
(Henstock_integrable_of_continuous_on hc).H_to_H'

lemma has_integral_McShane_inf_principal_of_forall_is_o [fintype Œπ] (B : box Œπ ‚Üí ‚Ñù)
  (HB : box_additive_on B I) (g : box Œπ ‚Üí F) (hg : box_additive_on g I) (p : (Œπ ‚Üí ‚Ñù) ‚Üí box Œπ ‚Üí Prop)
  (H : ‚àÄ (x ‚àà I.Icc) (Œµ > 0), ‚àÉ Œ¥ > 0, ‚àÄ J ‚â§ I, J.Icc ‚äÜ metric.closed_ball x Œ¥ ‚Üí p x J ‚Üí
    dist (vol J (f x)) (g J) ‚â§ Œµ * B J) :
  has_integral I (McShane ‚äì ùìü {œÄ | ‚àÄ J ‚àà œÄ, p (œÄ.tag J) J}) vol f (g I) :=
begin
  refine ((has_basis_McShane.inf_principal _).tendsto_iff metric.nhds_basis_closed_ball).2 _,
  intros Œµ Œµ0,
  choose! Œ¥ Œ¥0 HŒ¥Œµ using H, simp only [dist_eq_norm] at HŒ¥Œµ,
  have Hpos : 0 < max (B I) 1, from lt_max_iff.2 (or.inr zero_lt_one),
  refine ‚ü®Œª x, Œ¥ x (Œµ / max (B I) 1), Œª x hx, Œ¥0 x hx _ (div_pos Œµ0 Hpos), _‚ü©,
  rintro œÄ ‚ü®hœÄŒ¥, hœÄp‚ü©, rw mem_set_of_eq at hœÄŒ¥ hœÄp,
  erw [metric.mem_closed_ball, ‚Üê hg.finsum_mem_partition œÄ.to_partition, dist_eq_norm, integral_sum,
   œÄ.to_partition.finsum_eq_sum, œÄ.to_partition.finsum_eq_sum, ‚Üê finset.sum_sub_distrib],
  have : ‚àÄ J ‚àà œÄ.finite_boxes.to_finset, ‚à•vol J (f $ œÄ.tag J) - g J‚à• ‚â§ Œµ / max (B I) 1 * B J,
  { intros J hJ,
    rw finite.mem_to_finset at hJ,
    exact HŒ¥Œµ _ (œÄ.tag_mem_Icc _) _ (div_pos Œµ0 Hpos) _ (œÄ.to_partition.le_of_mem hJ) (hœÄŒ¥ J hJ)
      (hœÄp _ hJ) },
  refine (norm_sum_le_of_le _ this).trans _,
  rw [‚Üê finset.mul_sum, ‚Üê œÄ.to_partition.finsum_eq_sum, HB.finsum_mem_partition],
  rw [div_mul_eq_mul_div, div_le_iff Hpos],
  exact mul_le_mul_of_nonneg_left (le_max_left _ _) Œµ0.le
end

lemma has_integral_Henstock'_of_forall_is_o [fintype Œπ] (B : box Œπ ‚Üí ‚Ñù) (HB : box_additive_on B I)
  (g : box Œπ ‚Üí F) (hg : box_additive_on g I)
  (H : ‚àÄ (c : ‚Ñù‚â•0) (x ‚àà I.Icc) (Œµ > 0), ‚àÉ Œ¥ > 0, ‚àÄ J ‚â§ I, J.Icc ‚äÜ metric.closed_ball x Œ¥ ‚Üí
    x ‚àà J.Icc ‚Üí J.distortion ‚â§ c ‚Üí dist (vol J (f x)) (g J) ‚â§ Œµ * B J) :
  has_integral I Henstock' vol f (g I) :=
begin
  rw [Henstock'_def, has_integral, tendsto_supr],
  intro c, rw ‚Üê has_integral,
  convert has_integral_McShane_inf_principal_of_forall_is_o B HB g hg
    (Œª x J, x ‚àà J.Icc ‚àß J.distortion ‚â§ c) _,
  simpa only [and_imp] using H c
end

end box_integral
