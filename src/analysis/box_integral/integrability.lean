import analysis.box_integral.basic

open_locale classical nnreal ennreal topological_space big_operators

variables {Œπ E : Type*} [fintype Œπ] [normed_group E] [normed_space ‚Ñù E]

open measure_theory metric set finset filter box_integral

namespace box_integral

lemma has_integral_indicator_const (l : integration_filter) (hl : l.bRiemann = ff)
  {s : set (Œπ ‚Üí ‚Ñù)} (hs : measurable_set s) (I : box Œπ) (y : E)
  (Œº : measure (Œπ ‚Üí ‚Ñù)) [is_locally_finite_measure Œº] :
  @has_integral Œπ E E _ _ _ _ _ I l (s.indicator (Œª _, y)) Œº.to_box_additive.to_smul
    ((Œº (s ‚à© I)).to_real ‚Ä¢ y) :=
begin
  refine has_integral_of_mul (‚à•y‚à•) (Œª Œµ Œµ0, _),
  lift Œµ to ‚Ñù‚â•0 using Œµ0.le, rw nnreal.coe_pos at Œµ0,
  have A : Œº (s ‚à© I.Icc) ‚â† ‚àû,
    from ((measure_mono $ set.inter_subset_right _ _).trans_lt (I.measure_Icc_lt_top Œº)).ne,
  have B : Œº (s ‚à© I) ‚â† ‚àû,
    from ((measure_mono $ set.inter_subset_right _ _).trans_lt (I.measure_coe_lt_top Œº)).ne,
  rcases (hs.inter I.measurable_set_Icc).exists_is_closed_is_open_lt_add A
    (ennreal.coe_pos.2 Œµ0) with ‚ü®K, U, hKc, hUo, hKs, hsU, hŒºKU‚ü©,
  replace hŒºKU : Œº (U \ K) ‚â§ Œµ,
  { rw [measure_diff (hKs.trans hsU), ennreal.sub_le_iff_le_add'],
    exacts [hŒºKU.le, hUo.measurable_set, hKc.measurable_set,
      ne_top_of_le_ne_top A (measure_mono hKs)] },
  have : ‚àÄ x ‚àà s ‚à© I.Icc, ‚àÉ r : Ioi (0 : ‚Ñù), closed_ball x r ‚äÜ U,
    from Œª x hx, subtype.exists'.1 (nhds_basis_closed_ball.mem_iff.1 (hUo.mem_nhds $ hsU hx)),
  choose! rs hrsU,
  have : ‚àÄ x ‚àà I.Icc \ s, ‚àÉ r : Ioi (0 : ‚Ñù), closed_ball x r ‚äÜ K·∂ú,
    from Œª x hx, subtype.exists'.1 (nhds_basis_closed_ball.mem_iff.1 (hKc.is_open_compl.mem_nhds $
      Œª hx', hx.2 (hKs hx').1)),
  choose! rs' hrs'K,
  set r : (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) := s.piecewise rs rs',
  refine ‚ü®Œª c, r, Œª c, l.r_cond_of_bRiemann_eq_ff hl, Œª c œÄ hœÄ hœÄp, _‚ü©, rw mul_comm,
  dsimp [integral_sum],
  simp only [mem_closed_ball, dist_eq_norm, ‚Üê indicator_smul_apply, sum_indicator_eq_sum_filter,
    ‚Üê sum_smul, ‚Üê sub_smul, norm_smul, real.norm_eq_abs, ‚Üê prepartition.filter_boxes,
    ‚Üê prepartition.measure_Union_to_real],
  refine mul_le_mul_of_nonneg_right _ (norm_nonneg y),
  set t := (œÄ.to_prepartition.filter (Œª J, œÄ.tag J ‚àà s)).Union,
  change abs ((Œº t).to_real - (Œº (s ‚à© I)).to_real) ‚â§ Œµ,
  have htU : t ‚äÜ U ‚à© I,
  { simp only [t, prepartition.Union_def, Union_subset_iff, prepartition.mem_filter, and_imp],
    refine Œª J hJ hJs x hx, ‚ü®hrsU _ ‚ü®hJs, œÄ.tag_mem_Icc J‚ü©  _, œÄ.le_of_mem' J hJ hx‚ü©,
    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hœÄ.1 J hJ (box.coe_subset_Icc hx) },
  refine abs_sub_le_iff.2 ‚ü®_, _‚ü©,
  { refine (ennreal.le_to_real_sub B).trans (ennreal.to_real_le_coe_of_le_coe _),
    refine (ennreal.sub_le_sub (measure_mono htU) le_rfl).trans (le_measure_diff.trans _),
    refine (measure_mono $ Œª x hx, _).trans hŒºKU,
    exact ‚ü®hx.1.1, Œª hxK, hx.2 ‚ü®(hKs hxK).1, hx.1.2‚ü©‚ü© },
  { have hŒºt : Œº t ‚â† ‚àû :=
      ((measure_mono (htU.trans (inter_subset_right _ _))).trans_lt (I.measure_coe_lt_top _)).ne,
    refine (ennreal.le_to_real_sub hŒºt).trans (ennreal.to_real_le_coe_of_le_coe _),
    refine le_measure_diff.trans ((measure_mono _).trans hŒºKU),
    rintro x ‚ü®‚ü®hxs, hxI‚ü©, hxt‚ü©,
    refine ‚ü®hsU ‚ü®hxs, box.coe_subset_Icc hxI‚ü©, Œª hxK, hxt _‚ü©,
    simp only [t, prepartition.Union_def, prepartition.mem_filter, set.mem_Union, exists_prop],
    rcases hœÄp x hxI with ‚ü®J, hJœÄ, hxJ‚ü©,
    refine ‚ü®J, ‚ü®hJœÄ, _‚ü©, hxJ‚ü©,
    contrapose hxK,
    refine hrs'K _ ‚ü®œÄ.tag_mem_Icc J, hxK‚ü© _,
    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxK] using hœÄ.1 J hJœÄ (box.coe_subset_Icc hxJ) }
end

lemma has_integral_zero_of_ae_eq_zero {l : integration_filter} {I : box Œπ} {f : (Œπ ‚Üí ‚Ñù) ‚Üí E}
  {Œº : measure (Œπ ‚Üí ‚Ñù)} [is_locally_finite_measure Œº] (hf : f =·µê[Œº.restrict I] 0)
  (hl : l.bRiemann = ff) :
  @has_integral Œπ E E _ _ _ _ _ I l f Œº.to_box_additive.to_smul 0 :=
begin
  refine has_integral_iff.2 (Œª Œµ Œµ0, _),
  lift Œµ to ‚Ñù‚â•0 using Œµ0.lt.le, rw [gt_iff_lt, nnreal.coe_pos] at Œµ0,
  rcases nnreal.exists_pos_sum_of_encodable Œµ0 ‚Ñï with ‚ü®Œ¥, Œ¥0, c, hŒ¥c, hcŒµ‚ü©,
  haveI := fact.mk (I.measure_coe_lt_top Œº),
  change Œº.restrict I {x | f x ‚â† 0} = 0 at hf,
  set N : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñï := Œª x, ‚åà‚à•f x‚à•‚åâ‚Çä,
  have N0 : ‚àÄ {x}, N x = 0 ‚Üî f x = 0, by { intro x, simp [N] },
  have : ‚àÄ n, ‚àÉ U, is_open U ‚àß N ‚Åª¬π' {n} ‚äÜ U ‚àß Œº.restrict I U < Œ¥ n / n,
  { refine Œª n, (N ‚Åª¬π' {n}).exists_is_open_lt_of_lt _ _,
    cases n,
    { simpa [ennreal.div_zero (ennreal.coe_pos.2 (Œ¥0 _)).ne']
        using measure_lt_top (Œº.restrict I) _ },
    { refine (measure_mono_null _ hf).le.trans_lt _,
      { exact Œª x hxN hxf, n.succ_ne_zero ((eq.symm hxN).trans $ N0.2 hxf) },
      { simp [(Œ¥0 _).ne'] } } },
  choose U hUo hNU hŒºU,
  have : ‚àÄ x, ‚àÉ r : Ioi (0 : ‚Ñù), closed_ball x r ‚äÜ U (N x),
    from Œª x, subtype.exists'.1 (nhds_basis_closed_ball.mem_iff.1 ((hUo _).mem_nhds (hNU _ rfl))),
  choose r hrU,
  refine ‚ü®Œª _, r, Œª c, l.r_cond_of_bRiemann_eq_ff hl, Œª c œÄ hœÄ hœÄp, _‚ü©,
  rw [dist_eq_norm, sub_zero, ‚Üê integral_sum_fiberwise (Œª J, N (œÄ.tag J))],
  refine le_trans _ (nnreal.coe_lt_coe.2 hcŒµ).le,
  refine (norm_sum_le_of_le _ _).trans
    (sum_le_has_sum _ (Œª n _, (Œ¥ n).2) (nnreal.has_sum_coe.2 hŒ¥c)),
  rintro n -,
  dsimp [integral_sum],
  have : ‚àÄ J ‚àà œÄ.filter (Œª J, N (œÄ.tag J) = n),
    ‚à•(Œº ‚ÜëJ).to_real ‚Ä¢ f (œÄ.tag J)‚à• ‚â§ (Œº J).to_real * n,
  { intros J hJ, rw tagged_prepartition.mem_filter at hJ,
    rw [norm_smul, real.norm_eq_abs, abs_of_nonneg ennreal.to_real_nonneg],
    exact mul_le_mul_of_nonneg_left (hJ.2 ‚ñ∏ le_nat_ceil _) ennreal.to_real_nonneg },
  refine (norm_sum_le_of_le _ this).trans _, clear this,
  rw [‚Üê sum_mul, ‚Üê prepartition.measure_Union_to_real],
  generalize hm : Œº (œÄ.filter (Œª J, N (œÄ.tag J) = n)).Union = m,
  have : m < Œ¥ n / n,
  { simp only [measure.restrict_apply (hUo _).measurable_set] at hŒºU,
    refine hm ‚ñ∏ (measure_mono _).trans_lt (hŒºU _),
    simp only [set.subset_def, tagged_prepartition.mem_Union, exists_prop,
      tagged_prepartition.mem_filter],
    rintro x ‚ü®J, ‚ü®hJ, rfl‚ü©, hx‚ü©,
    exact ‚ü®hrU _ (hœÄ.1 _ hJ (box.coe_subset_Icc hx)), œÄ.le_of_mem' J hJ hx‚ü© },
  lift m to ‚Ñù‚â•0 using ne_top_of_lt this,
  rw [ennreal.coe_to_real, ‚Üê nnreal.coe_nat_cast, ‚Üê nnreal.coe_mul, nnreal.coe_le_coe,
    ‚Üê ennreal.coe_le_coe, ennreal.coe_mul, ennreal.coe_nat, mul_comm],
  exact (mul_le_mul_left' this.le _).trans ennreal.mul_div_le
end

lemma has_integral.congr_ae {l : integration_filter} {I : box Œπ} {y : E} {f g : (Œπ ‚Üí ‚Ñù) ‚Üí E}
  {Œº : measure (Œπ ‚Üí ‚Ñù)} [is_locally_finite_measure Œº]
  (hf : @has_integral Œπ E E _ _ _ _ _ I l f Œº.to_box_additive.to_smul y)
  (hfg : f =·µê[Œº.restrict I] g) (hl : l.bRiemann = ff) :
  @has_integral Œπ E E _ _ _ _ _ I l g Œº.to_box_additive.to_smul y :=
begin
  have : (g - f) =·µê[Œº.restrict I] 0, from hfg.mono (Œª x hx, sub_eq_zero.2 hx.symm),
  simpa using hf.add (has_integral_zero_of_ae_eq_zero this hl)
end

end box_integral

namespace measure_theory

namespace simple_func

lemma has_box_integral (f : simple_func (Œπ ‚Üí ‚Ñù) E) (Œº : measure (Œπ ‚Üí ‚Ñù))
  [is_locally_finite_measure Œº] (I : box Œπ) (l : integration_filter) (hl : l.bRiemann = ff) :
  @has_integral Œπ E E _ _ _ _ _ I l f Œº.to_box_additive.to_smul (f.integral (Œº.restrict I)) :=
begin
  induction f using measure_theory.simple_func.induction with y s hs f g hd hfi hgi,
  { simpa [function.const, measure.restrict_apply hs]
      using box_integral.has_integral_indicator_const l hl hs I y Œº },
  { letI := borel E, haveI : borel_space E := ‚ü®rfl‚ü©, haveI := fact.mk (I.measure_coe_lt_top Œº),
    rw integral_add,
    exacts [hfi.add hgi, integrable_iff.2 $ Œª _ _, measure_lt_top _ _,
      integrable_iff.2 $ Œª _ _, measure_lt_top _ _] }
end

lemma box_integral_eq_integral (f : simple_func (Œπ ‚Üí ‚Ñù) E) (Œº : measure (Œπ ‚Üí ‚Ñù))
  [is_locally_finite_measure Œº] (I : box Œπ) (l : integration_filter) (hl : l.bRiemann = ff) :
  @box_integral.integral Œπ E E _ _ _ _ _ I l f Œº.to_box_additive.to_smul =
    f.integral (Œº.restrict I) :=
(f.has_box_integral Œº I l hl).integral_eq

end simple_func

open topological_space

lemma integrable_on.has_box_integral [second_countable_topology E] [measurable_space E] [borel_space E]
  [complete_space E] {f : (Œπ ‚Üí ‚Ñù) ‚Üí E} {Œº : measure (Œπ ‚Üí ‚Ñù)} [is_locally_finite_measure Œº]
  {I : box Œπ} (hf : integrable_on f I Œº) (l : integration_filter) (hl : l.bRiemann = ff) :
  @has_integral Œπ E E _ _ _ _ _ I l f Œº.to_box_additive.to_smul (‚à´ x in I, f x ‚àÇ Œº) :=
begin
  rcases hf.ae_measurable with ‚ü®g, hg, hfg‚ü©,
  rw integral_congr_ae hfg, have hgi : integrable_on g I Œº := (integrable_congr hfg).1 hf,
  refine box_integral.has_integral.congr_ae _ hfg.symm hl,
  clear_dependent f,
  set f : ‚Ñï ‚Üí simple_func (Œπ ‚Üí ‚Ñù) E := simple_func.approx_on g hg univ 0 trivial,
  have hfi : ‚àÄ n, integrable_on (f n) I Œº, from simple_func.integrable_approx_on_univ hg hgi,
  have hfi' := Œª n, ((f n).has_box_integral Œº I l hl).integrable,
  have hfgi : tendsto (Œª n, (f n).integral (Œº.restrict I)) at_top (ùìù $ ‚à´ x in I, g x ‚àÇŒº),
    from tendsto_integral_approx_on_univ_of_measurable hg hgi,
  have hfg_mono : ‚àÄ x {m n}, m ‚â§ n ‚Üí ‚à•f n x - g x‚à• ‚â§ ‚à•f m x - g x‚à•,
  { intros x m n hmn,
    rw [‚Üê dist_eq_norm, ‚Üê dist_eq_norm, dist_nndist, dist_nndist, nnreal.coe_le_coe,
      ‚Üê ennreal.coe_le_coe, ‚Üê edist_nndist, ‚Üê edist_nndist],
    exact simple_func.edist_approx_on_mono hg _ x hmn },
  refine has_integral_of_mul ((Œº I).to_real + 1 + 1) (Œª Œµ Œµ0, _),
  lift Œµ to ‚Ñù‚â•0 using Œµ0.le, rw nnreal.coe_pos at Œµ0, have Œµ0' := ennreal.coe_pos.2 Œµ0,
  obtain ‚ü®N‚ÇÄ, hN‚ÇÄ‚ü© : ‚àÉ N : ‚Ñï, ‚à´ x in I, ‚à•f N x - g x‚à• ‚àÇŒº ‚â§ Œµ,
  { have : tendsto (Œª n, ‚à´‚Åª x in I, ‚à•f n x - g x‚à•‚Çä ‚àÇŒº) at_top (ùìù 0),
      from simple_func.tendsto_approx_on_univ_L1_nnnorm hg hgi,
    refine (this.eventually (ge_mem_nhds Œµ0')).exists.imp (Œª N hN, _),
    exact integral_coe_le_of_lintegral_coe_le hN },
  have : ‚àÄ x, ‚àÉ N‚ÇÅ, N‚ÇÄ ‚â§ N‚ÇÅ ‚àß dist (f N‚ÇÅ x) (g x) ‚â§ Œµ,
  { intro x,
    have : tendsto (Œª n, f n x) at_top (ùìù $ g x),
      from simple_func.tendsto_approx_on hg _ (subset_closure trivial),
    exact ((eventually_ge_at_top N‚ÇÄ).and $ this $ closed_ball_mem_nhds _ Œµ0).exists },
  choose Nx hNx hNxŒµ,
  rcases nnreal.exists_pos_sum_of_encodable Œµ0 ‚Ñï with ‚ü®Œ¥, Œ¥0, c, hŒ¥c, hcŒµ‚ü©,
  set r : ‚Ñù‚â•0 ‚Üí (Œπ ‚Üí ‚Ñù) ‚Üí Ioi (0 : ‚Ñù) := Œª c x, (hfi' $ Nx x).convergence_r (Œ¥ $ Nx x) c x,
  refine ‚ü®r, Œª c, l.r_cond_of_bRiemann_eq_ff hl, Œª c œÄ hœÄ hœÄp, _‚ü©,
  refine (dist_triangle4 _ (‚àë J in œÄ.boxes, (Œº J).to_real ‚Ä¢ f (Nx $ œÄ.tag J) (œÄ.tag J))
    (‚àë J in œÄ.boxes, ‚à´ x in J, f (Nx $ œÄ.tag J) x ‚àÇŒº) _).trans _,
  rw [add_mul, add_mul, one_mul],
  refine add_le_add_three _ _ _,
  { rw [‚Üê hœÄp.Union_eq, œÄ.to_prepartition.measure_Union_to_real, sum_mul, integral_sum],
    refine dist_sum_sum_le_of_le _ (Œª J hJ, _), dsimp,
    rw [dist_eq_norm, ‚Üê smul_sub, norm_smul, real.norm_eq_abs,
      abs_of_nonneg ennreal.to_real_nonneg],
    refine mul_le_mul_of_nonneg_left _ ennreal.to_real_nonneg,
    rw [‚Üê dist_eq_norm'], exact hNxŒµ _ },
  { rw [‚Üê œÄ.to_prepartition.sum_fiberwise (Œª J, Nx (œÄ.tag J)),
      ‚Üê œÄ.to_prepartition.sum_fiberwise (Œª J, Nx (œÄ.tag J))],
    refine le_trans _ (nnreal.coe_lt_coe.2 hcŒµ).le,
    refine (dist_sum_sum_le_of_le _ (Œª n hn, _)).trans
      (sum_le_has_sum _ (Œª n _, (Œ¥ n).2) (nnreal.has_sum_coe.2 hŒ¥c)),
    have hNxn : ‚àÄ J ‚àà œÄ.filter (Œª J, Nx (œÄ.tag J) = n), Nx (œÄ.tag J) = n,
      from Œª J hJ, (œÄ.mem_filter.1 hJ).2,
    have hrn : ‚àÄ J ‚àà œÄ.filter (Œª J, Nx (œÄ.tag J) = n),
      r c (œÄ.tag J) = (hfi' n).convergence_r (Œ¥ n) c (œÄ.tag J),
    { intros J hJ, have := hNxn J hJ, clear hJ, subst n },
    have : l.mem_base_set I c ((hfi' n).convergence_r (Œ¥ n) c) (œÄ.filter (Œª J, Nx (œÄ.tag J) = n)),
      from (hœÄ.filter _).mono' _ le_rfl le_rfl (Œª J hJ, (hrn J hJ).le),
    convert (hfi' n).dist_integral_sum_sum_integral_le_of_mem_base_set (Œ¥0 _) this using 2,
    { refine sum_congr rfl (Œª J hJ, _),
      simp [hNxn J hJ] },
    { refine sum_congr rfl (Œª J hJ, _),
      rw [‚Üê simple_func.integral_eq_integral, simple_func.box_integral_eq_integral _ _ _ _ hl,
        hNxn J hJ],
      exact (hfi _).mono_set (prepartition.le_of_mem _ hJ) } },
  { refine le_trans _ hN‚ÇÄ,
    have hfi : ‚àÄ n (J ‚àà œÄ), integrable_on (f n) ‚ÜëJ  Œº,
      from Œª n J hJ, (hfi n).mono_set (œÄ.le_of_mem' J hJ),
    have hgi : ‚àÄ J ‚àà œÄ, integrable_on g ‚ÜëJ Œº, from Œª J hJ, hgi.mono_set (œÄ.le_of_mem' J hJ),
    have hfgi : ‚àÄ n (J ‚àà œÄ), integrable_on (Œª x, ‚à•f n x - g x‚à•) J Œº,
      from Œª n J hJ, ((hfi n J hJ).sub (hgi J hJ)).norm,
    rw [‚Üê hœÄp.Union_eq, prepartition.Union_def',
      integral_finset_bUnion œÄ.boxes (Œª J hJ, J.measurable_set_coe) hgi œÄ.pairwise_disjoint,
      integral_finset_bUnion œÄ.boxes (Œª J hJ, J.measurable_set_coe) (hfgi _) œÄ.pairwise_disjoint],
    refine dist_sum_sum_le_of_le _ (Œª J hJ, _),
    rw [dist_eq_norm, ‚Üê integral_sub (hfi _ J hJ) (hgi J hJ)],
    refine norm_integral_le_of_norm_le (hfgi _ J hJ) (eventually_of_forall $ Œª x, _),
    exact hfg_mono x (hNx (œÄ.tag J)) }
end

end measure_theory
