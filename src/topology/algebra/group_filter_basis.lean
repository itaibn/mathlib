import order.filter.bases
import topology.algebra.group
/-!

# Group flter bases

A `group_filter_basis` is a `filter_basis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `group_filter_basis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

-/
open filter set
open_locale topological_space

-- The next lemma seems missing from mathlib, it should be in order.filter.bases

protected lemma filter_basis.has_basis {α : Type*} (B : filter_basis α) :
  has_basis (B.filter) (λ s : set α, s ∈ B) id :=
⟨λ t, B.mem_filter_iff⟩

universe u

/-- A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topological
  group structure on `G`.  -/
class group_filter_basis (G : Type u) [group G] extends filter_basis G :=
(one' : ∀ {U}, U ∈ sets → (1 : G) ∈ U)
(mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U)
(inv' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (λ x, x⁻¹) ⁻¹' U)
(conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (λ x, x₀*x*x₀⁻¹) ⁻¹' U)

/-- A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topological
  group structure on `G`.  -/
class add_group_filter_basis (A : Type u) [add_group A] extends filter_basis A :=
(zero' : ∀ {U}, U ∈ sets → (0 : A) ∈ U)
(add' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V + V ⊆ U)
(neg' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (λ x, -x) ⁻¹' U)
(conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (λ x, x₀+x-x₀) ⁻¹' U)

attribute [to_additive] group_filter_basis
attribute [to_additive] group_filter_basis.one'
attribute [to_additive] group_filter_basis.mul'
attribute [to_additive] group_filter_basis.inv'
attribute [to_additive] group_filter_basis.conj'
attribute [to_additive] group_filter_basis.to_filter_basis

namespace group_filter_basis
variables {G : Type u} [group G] {B : group_filter_basis G}

open filter

@[to_additive]
instance group_filter_basis.has_mem : has_mem (set G) (group_filter_basis G) :=
⟨λ s f, s ∈ f.sets⟩

@[to_additive] lemma one {U : set G} : U ∈ B → (1 : G) ∈ U := group_filter_basis.one'

@[to_additive] lemma mul {U : set G} : U ∈ B → ∃ V ∈ B, V*V ⊆ U := group_filter_basis.mul'

@[to_additive] lemma inv {U : set G} : U ∈ B → ∃ V ∈ B, V ⊆ (λ x, x⁻¹) ⁻¹' U :=
group_filter_basis.inv'

lemma conj : ∀ x₀, ∀ {U}, U ∈ B → ∃ V ∈ B, V ⊆ (λ x, x₀*x*x₀⁻¹) ⁻¹' U :=
group_filter_basis.conj'

lemma _root_.add_group_filter_basis.conj {G : Type u} [add_group G] {B : add_group_filter_basis G} :
  ∀ x₀, ∀ {U}, U ∈ B → ∃ V ∈ B, V ⊆ (λ x, x₀+x-x₀) ⁻¹' U :=
add_group_filter_basis.conj'

@[to_additive]
lemma prod_subset_self (B : group_filter_basis G) {U : set G} (h : U ∈ B) : U ⊆ U * U :=
λ x x_in, ⟨1, x, one h, x_in, one_mul x⟩

/-- The neighborhood function of a `group_filter_basis` -/
@[to_additive]
def N (B : group_filter_basis G) : G → filter G :=
λ x, map (λ y, x*y) B.to_filter_basis.filter

@[simp, to_additive]
lemma N_one (B : group_filter_basis G) : B.N 1 = B.to_filter_basis.filter :=
by simp only [N, one_mul, map_id']

-- The next lemma connects to the new mathlib filter.has_basis
@[to_additive]
protected lemma has_basis (B : group_filter_basis G) (x : G) :
  has_basis (B.N x) (λ V : set G, V ∈ B) (λ V, (λ y, x*y) '' V) :=
has_basis.map (λ y, x * y) to_filter_basis.has_basis

-- This lemma is now redundant because of the above one
/- @[to_additive]
lemma mem_N (f : group_filter_basis G) (x : G) (U : set G) :
  U ∈ f.N x ↔ ∃ V ∈ f, (λ y, x*y) '' V ⊆ U :=
(f.has_basis x).mem_iff -/

-- The following is an internal technical lemma but it will be used twice.
@[to_additive]
lemma N_is_nice (B : group_filter_basis G) :
  (pure ≤ B.N) ∧
  ∀ {a s}, s ∈ B.N a → ∃ t ∈ B.N a, t ⊆ s ∧ ∀ a' ∈ t, s ∈ B.N a' :=
begin
  split,
  { intros x U U_in,
    rw (B.has_basis x).mem_iff at U_in,
    rcases U_in with ⟨V, V_in, H⟩,
    simpa [mem_pure_sets] using H (mem_image_of_mem _ (group_filter_basis.one V_in)), },
  { intros x U U_in,
    rw (B.has_basis x).mem_iff at U_in,
    rcases U_in with ⟨V, V_in, H⟩,
    rcases group_filter_basis.mul V_in with ⟨W, W_in, hW⟩,
    use [(λ y, x*y) '' W, image_mem_map (filter_basis.mem_filter_of_mem _ W_in)],
    split,
    { rw image_subset_iff at H ⊢,
      exact ((B.prod_subset_self W_in).trans hW).trans H },
    { rintros y ⟨t, tW, rfl⟩,
      rw (B.has_basis _).mem_iff,
      use [W, W_in],
      apply subset.trans _ H, clear H,
      rintros z ⟨w, wW, rfl⟩,
      exact ⟨t*w, hW (mul_mem_mul tW wW), by simp [mul_assoc]⟩ } }
end


/-- The topological group associated with a group filter basis. -/
--@[to_additive]
lemma to_topological_group [topological_space G]
  (B : group_filter_basis G) (hnhds : ∀ x₀ : G, nhds x₀ = B.N x₀) : topological_group G :=
begin
  refine topological_group.of_nhds_one _ _ _ _,
  { rw [hnhds 1, N_one],
    intros V V_in,
    rcases V_in with ⟨W₀, W₀_in, hW₀⟩,
    rcases mul W₀_in with ⟨W, W_in, hW⟩,
    rw [filter.mem_map, filter.mem_prod_iff],
    use [W, to_filter_basis.mem_filter_of_mem W_in, W, to_filter_basis.mem_filter_of_mem W_in],
    intros w hw,
    apply hW.trans hW₀,
    use [w.1, w.2, hw.1, hw.2],
    rwa function.uncurry },
  { rw [hnhds 1, N_one],
    intros V V_in,
    rcases V_in with ⟨W₀, W₀_in, hW₀⟩,
    rcases inv W₀_in with ⟨W, W_in, hW⟩,
    rw filter.mem_map,
    use [W, W_in],
    exact id (λ w hw, hW₀ (hW hw)) },
  { intro x₀,
    rw [hnhds x₀, hnhds 1, N],
    simp only [one_mul, filter.map_id'] },
  { intro x₀,
    rw [hnhds 1, N_one],
    intros V V_in,
    rcases V_in with ⟨W₀, W₀_in, hW₀⟩,
    rcases conj x₀ W₀_in with ⟨W, W_in, hW⟩,
    rw filter.mem_map,
    use [W, W_in, λ h hw, hW₀ $ hW hw] }
end

lemma _root_.add_group_filter_basis.to_topological_group {G : Type*} [add_group G]
  [topological_space G] (B : add_group_filter_basis G)
  (hnhds : ∀ x₀ : G, nhds x₀ = B.N x₀) : topological_add_group G :=
begin
  refine topological_add_group.of_nhds_zero _ _ _ _,
  { rw [hnhds 0, B.N_zero],
    intros V V_in,
    rcases V_in with ⟨W₀, W₀_in, hW₀⟩,
    rcases add_group_filter_basis.add W₀_in with ⟨W, W_in, hW⟩,
    rw [filter.mem_map, filter.mem_prod_iff],
    use [W, add_group_filter_basis.to_filter_basis.mem_filter_of_mem W_in, W,
         add_group_filter_basis.to_filter_basis.mem_filter_of_mem W_in],
    intros w hw,
    apply hW.trans hW₀,
    use [w.1, w.2, hw.1, hw.2],
    rwa function.uncurry },
  { rw [hnhds 0, B.N_zero],
    intros V V_in,
    rcases V_in with ⟨W₀, W₀_in, hW₀⟩,
    rcases add_group_filter_basis.neg W₀_in with ⟨W, W_in, hW⟩,
    rw filter.mem_map,
    use [W, W_in],
    exact id (λ w hw, hW₀ (hW hw)) },
  { intro x₀,
    rw [hnhds x₀, hnhds 0],
    change (λ x, map (λ y, x + y) add_group_filter_basis.to_filter_basis.filter) x₀ =
      map (λ x, x₀ + x) ((λ x, map (λ y, x + y) add_group_filter_basis.to_filter_basis.filter) 0),
    simp only [zero_add, filter.map_id'] },
  { intro x₀,
    rw [hnhds 0, B.N_zero],
    intros V V_in,
    rcases V_in with ⟨W₀, W₀_in, hW₀⟩,
    rcases add_group_filter_basis.conj x₀ W₀_in with ⟨W, W_in, hW⟩,
    simp_rw [filter.mem_map, ← sub_eq_add_neg],
    use [W, W_in, λ h hw, hW₀ $ hW hw] }
end


/-- The topological space structure coming a group filter basis. -/
@[to_additive]
def topology (B : group_filter_basis G) : topological_space G :=
topological_space.mk_of_nhds B.N

/-- The topological space structure coming a group filter basis. Version using tc resolution -/
@[to_additive]
def to_topological_space [basis : group_filter_basis G] : topological_space G :=
basis.topology

@[to_additive]
lemma nhds_eq (B : group_filter_basis G) {x₀ : G} :
  @nhds G (B.topology) x₀ = B.N x₀ :=
by rw [topological_space.nhds_mk_of_nhds _ x₀ B.N_is_nice.1 B.N_is_nice.2]


end group_filter_basis
